{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to the T\u00d6VE Docs. This is a work in progress.","title":"Welcome to the T\u00d6VE Docs."},{"location":"#welcome-to-the-tove-docs","text":"This is a work in progress.","title":"Welcome to the T\u00d6VE Docs."},{"location":"collections/","text":"Collections in T\u00d6VE are table-like objects that hold paths, subpaths, and curves. Count collection.count yields the number of elements in collection . For example, graphics.paths.count gets the number of paths in graphics . By Index collection[i] yields the i -th element in collection . i is 1-based. For example, graphics.paths[1] gets the first path in graphics . By Name collection.name yields the element named name . For example, graphics.paths[1].subpaths[1].curves[2].cp1x yields the x coordinate of path 1, subpath 1, curve 2 in graphics .","title":"Collections"},{"location":"collections/#count","text":"collection.count yields the number of elements in collection . For example, graphics.paths.count gets the number of paths in graphics .","title":"Count"},{"location":"collections/#by-index","text":"collection[i] yields the i -th element in collection . i is 1-based. For example, graphics.paths[1] gets the first path in graphics .","title":"By Index"},{"location":"collections/#by-name","text":"collection.name yields the element named name . For example, graphics.paths[1].subpaths[1].curves[2].cp1x yields the x coordinate of path 1, subpath 1, curve 2 in graphics .","title":"By Name"},{"location":"colors/","text":"All methods that take colors as parameters allow 5 different ways to specify colors. RGB Use r, g, b to specify the RGB color (r, g, b) . path:setFillColor(1, 0.5, 0.2) RGBA Use r, g, b, a to specify the RGB color (r, g, b) with alpha value a . path:setFillColor(1, 0, 0.1, 0.5) Hex String path:setFillColor(\"#aabbcc\") Paint Object use a preconstructed Paint object. local p = tove.newPaint{type=\"solid\", color={0.5, 0.2, 0.1}} path:setFillColor(p) Nothing nil indicates that no color (e.g. no fill) should be used. path:setFillColor(nil)","title":"Colors"},{"location":"colors/#rgb","text":"Use r, g, b to specify the RGB color (r, g, b) . path:setFillColor(1, 0.5, 0.2)","title":"RGB"},{"location":"colors/#rgba","text":"Use r, g, b, a to specify the RGB color (r, g, b) with alpha value a . path:setFillColor(1, 0, 0.1, 0.5)","title":"RGBA"},{"location":"colors/#hex-string","text":"path:setFillColor(\"#aabbcc\")","title":"Hex String"},{"location":"colors/#paint-object","text":"use a preconstructed Paint object. local p = tove.newPaint{type=\"solid\", color={0.5, 0.2, 0.1}} path:setFillColor(p)","title":"Paint Object"},{"location":"colors/#nothing","text":"nil indicates that no color (e.g. no fill) should be used. path:setFillColor(nil)","title":"Nothing"},{"location":"graphics/","text":"Overview Graphics is the main class for constructing and drawing things in T\u00d6VE. A Graphics object knows about the things it should draw, and the quality with which things should get drawn. Each Graphics consists of a number of Path s. Construction tove.newGraphics() create an empty Graphics object for drawing into. tove.newGraphics(svg, [size:GraphicsSize]) create a Graphics from the given SVG string (the actual data, not the filename). tove.newGraphics({path_1, ..., path_n}, [size]) construct a Graphics from the given Path objects. size behaves as above. Methods clone() : Graphics creates a deep copy of this Graphics object. clear() remove all Path s from this Graphics . beginPath() : Path start a new Path for drawing (without closing the current Path and making it a loop). closePath() close the current Path (making it a loop). Ensuing drawing commands on this Graphics will open a new path. beginSubpath() : SubPath inside the current Path , begin a new Subpath for drawing (without making the current Subpath a loop). Subsequent commands like lineTo will happen in that new Subpath . closeSubpath() inside the current Path , close the current Subpath (making it a loop). Ensuing drawing commands on this Graphics will draw to the same Path as before, but in a new Subpath . Use this if you want to draw holes. getCurrentPath() : Path return the current Path . moveTo(x, y) start a new SubPath and move the cursor to position (x, y) . lineTo(x, y) starting at the current position, draw a line to (x, y) . curveTo(cpx1, cpy1, cpx2, cpy2, x, y) starting at the current position, draw a cubic bezier curve to (x, y) , using (cpx1, cpy1) and (cpx2, cpy2) as control points. arc(x, y, r, startAngle, endAngle, counterclockwise) draw an arc with radius r from startAngle to endAngle going clockwise or counterclockwise (if counterclockwise is true ). addPath(path:Path) append the given path to this Graphics . drawRect(x, y, w, h, [rx], [ry]) draw a rectangle with (x, y) as the top left corner and with width w and height w . rx and ry specify the roundedness of the corners. drawCircle(x, y, r) draw a circle centered at (x, y) with radius r . drawEllipse(x, y, rx, ry) draw an ellipse centered at (x, y) with semi axes rx and ry . setFillColor([color...]) set the fill to the given color . setLineColor([color...]) set the line color to the given color . setLineDash(width_1, ..., width_n) set the line dash to widths width_1 , ..., width_n . setLineDashOffset(offset) set the line dash offset to offset . setLineWidth(width) set the line width to width . setMiterLimit(limit) set the miter limit (length at which miters are turned into bezels) to limit . fill() add a fill to the current path. stroke() add a stroke (line) to the current path. computeAABB([precision:AABBPrecision]):x0, y0, x1, y1 compute axis-aligned bounding box. getWidth([precision:AABBPrecision]) get Graphics 's width (how wide it is when drawn with scale 1). getHeight([precision:AABBPrecision]) get Graphics 's height (how high it is when drawn with scale 1). setDisplay(mode:DisplayMode, [quality]) general form of the setDisplay method. see specific forms below. setDisplay(\"texture\", [quality]) when drawing this Graphics , use a texture drawn through a single quad. note that this display mode does not take a quality parameter. if you want to change the texture resolution, use setResolution . quality is either \"best\" (default) or \"fast\" . setDisplay(\"mesh\", [tesselator...]) when rendering this Graphics , use a a mesh constructed using the specified tesselator . If no tesselator is given, a default one is picked based on the Graphics usage (see setUsage ). If instead of a tesselator, a number is given, this number will specify a quality using the default tesselator for the configured usage. setDisplay(\"gpux\", [lineShader], [lineQuality]) when rendering this Graphics , use an experimental GPU-based approach (rendering implicit surfaces using shaders). lineShader is either \"fragment\" or \"vertex\" . lineQuality is a number between 0 and 1. setUsage(what:UsageTarget, usage:Usage) setResolution(resolution) indicates up to which scale this Graphics should look crisp when displaying it through a scale transform. For example, a resolution of 1 indicates that you intend to apply no scaling. A resolution of 3 indicates, that you intend to display the Graphics up to three times its normal size. In case of texture displays, this will simply scale the underlying image by the given factor, giving you an unpixelated image at the desired scale factor. For mesh , the tesselation is applied to the blown up vector data. Note that increasing resolution does not affect the output size when drawing. It only affects the underlying display quality. setOrientation(orientation:Orientation) Ensure that the orientation of all Subpath s in this Graphics is the given orientation . Attributes paths gives you the Path s in this Graphics as a collection . Types GraphicsSize \"copy\" \"auto\" (default) number AABBPrecision \"low\" \"high\" The latter computation will exactly estimate certain line extensions like miters, but it will be much slower. DisplayMode \"texture\" \"mesh\" \"gpux\" Orientation \"cw\" specifies clockwise orientation. \"ccw\" specifies counterclockwise orientation.","title":"Graphics"},{"location":"graphics/#overview","text":"Graphics is the main class for constructing and drawing things in T\u00d6VE. A Graphics object knows about the things it should draw, and the quality with which things should get drawn. Each Graphics consists of a number of Path s.","title":"Overview"},{"location":"graphics/#construction","text":"","title":"Construction"},{"location":"graphics/#tovenewgraphics","text":"create an empty Graphics object for drawing into.","title":"tove.newGraphics()"},{"location":"graphics/#tovenewgraphicssvg-sizegraphicssize","text":"create a Graphics from the given SVG string (the actual data, not the filename).","title":"tove.newGraphics(svg, [size:GraphicsSize])"},{"location":"graphics/#tovenewgraphicspath_1-path_n-size","text":"construct a Graphics from the given Path objects. size behaves as above.","title":"tove.newGraphics({path_1, ..., path_n}, [size])"},{"location":"graphics/#methods","text":"","title":"Methods"},{"location":"graphics/#clone-graphics","text":"creates a deep copy of this Graphics object.","title":"clone() : Graphics"},{"location":"graphics/#clear","text":"remove all Path s from this Graphics .","title":"clear()"},{"location":"graphics/#beginpath-path","text":"start a new Path for drawing (without closing the current Path and making it a loop).","title":"beginPath() : Path"},{"location":"graphics/#closepath","text":"close the current Path (making it a loop). Ensuing drawing commands on this Graphics will open a new path.","title":"closePath()"},{"location":"graphics/#beginsubpath-subpath","text":"inside the current Path , begin a new Subpath for drawing (without making the current Subpath a loop). Subsequent commands like lineTo will happen in that new Subpath .","title":"beginSubpath() : SubPath"},{"location":"graphics/#closesubpath","text":"inside the current Path , close the current Subpath (making it a loop). Ensuing drawing commands on this Graphics will draw to the same Path as before, but in a new Subpath . Use this if you want to draw holes.","title":"closeSubpath()"},{"location":"graphics/#getcurrentpath-path","text":"return the current Path .","title":"getCurrentPath() : Path"},{"location":"graphics/#movetox-y","text":"start a new SubPath and move the cursor to position (x, y) .","title":"moveTo(x, y)"},{"location":"graphics/#linetox-y","text":"starting at the current position, draw a line to (x, y) .","title":"lineTo(x, y)"},{"location":"graphics/#curvetocpx1-cpy1-cpx2-cpy2-x-y","text":"starting at the current position, draw a cubic bezier curve to (x, y) , using (cpx1, cpy1) and (cpx2, cpy2) as control points.","title":"curveTo(cpx1, cpy1, cpx2, cpy2, x, y)"},{"location":"graphics/#arcx-y-r-startangle-endangle-counterclockwise","text":"draw an arc with radius r from startAngle to endAngle going clockwise or counterclockwise (if counterclockwise is true ).","title":"arc(x, y, r, startAngle, endAngle, counterclockwise)"},{"location":"graphics/#addpathpathpath","text":"append the given path to this Graphics .","title":"addPath(path:Path)"},{"location":"graphics/#drawrectx-y-w-h-rx-ry","text":"draw a rectangle with (x, y) as the top left corner and with width w and height w . rx and ry specify the roundedness of the corners.","title":"drawRect(x, y, w, h, [rx], [ry])"},{"location":"graphics/#drawcirclex-y-r","text":"draw a circle centered at (x, y) with radius r .","title":"drawCircle(x, y, r)"},{"location":"graphics/#drawellipsex-y-rx-ry","text":"draw an ellipse centered at (x, y) with semi axes rx and ry .","title":"drawEllipse(x, y, rx, ry)"},{"location":"graphics/#setfillcolorcolor","text":"set the fill to the given color .","title":"setFillColor([color...])"},{"location":"graphics/#setlinecolorcolor","text":"set the line color to the given color .","title":"setLineColor([color...])"},{"location":"graphics/#setlinedashwidth_1-width_n","text":"set the line dash to widths width_1 , ..., width_n .","title":"setLineDash(width_1, ..., width_n)"},{"location":"graphics/#setlinedashoffsetoffset","text":"set the line dash offset to offset .","title":"setLineDashOffset(offset)"},{"location":"graphics/#setlinewidthwidth","text":"set the line width to width .","title":"setLineWidth(width)"},{"location":"graphics/#setmiterlimitlimit","text":"set the miter limit (length at which miters are turned into bezels) to limit .","title":"setMiterLimit(limit)"},{"location":"graphics/#fill","text":"add a fill to the current path.","title":"fill()"},{"location":"graphics/#stroke","text":"add a stroke (line) to the current path.","title":"stroke()"},{"location":"graphics/#computeaabbprecisionaabbprecisionx0-y0-x1-y1","text":"compute axis-aligned bounding box.","title":"computeAABB([precision:AABBPrecision]):x0, y0, x1, y1"},{"location":"graphics/#getwidthprecisionaabbprecision","text":"get Graphics 's width (how wide it is when drawn with scale 1).","title":"getWidth([precision:AABBPrecision])"},{"location":"graphics/#getheightprecisionaabbprecision","text":"get Graphics 's height (how high it is when drawn with scale 1).","title":"getHeight([precision:AABBPrecision])"},{"location":"graphics/#setdisplaymodedisplaymode-quality","text":"general form of the setDisplay method. see specific forms below.","title":"setDisplay(mode:DisplayMode, [quality])"},{"location":"graphics/#setdisplaytexture-quality","text":"when drawing this Graphics , use a texture drawn through a single quad. note that this display mode does not take a quality parameter. if you want to change the texture resolution, use setResolution . quality is either \"best\" (default) or \"fast\" .","title":"setDisplay(\"texture\", [quality])"},{"location":"graphics/#setdisplaymesh-tesselator","text":"when rendering this Graphics , use a a mesh constructed using the specified tesselator . If no tesselator is given, a default one is picked based on the Graphics usage (see setUsage ). If instead of a tesselator, a number is given, this number will specify a quality using the default tesselator for the configured usage.","title":"setDisplay(\"mesh\", [tesselator...])"},{"location":"graphics/#setdisplaygpux-lineshader-linequality","text":"when rendering this Graphics , use an experimental GPU-based approach (rendering implicit surfaces using shaders). lineShader is either \"fragment\" or \"vertex\" . lineQuality is a number between 0 and 1.","title":"setDisplay(\"gpux\", [lineShader], [lineQuality])"},{"location":"graphics/#setusagewhatusagetarget-usageusage","text":"","title":"setUsage(what:UsageTarget, usage:Usage)"},{"location":"graphics/#setresolutionresolution","text":"indicates up to which scale this Graphics should look crisp when displaying it through a scale transform. For example, a resolution of 1 indicates that you intend to apply no scaling. A resolution of 3 indicates, that you intend to display the Graphics up to three times its normal size. In case of texture displays, this will simply scale the underlying image by the given factor, giving you an unpixelated image at the desired scale factor. For mesh , the tesselation is applied to the blown up vector data. Note that increasing resolution does not affect the output size when drawing. It only affects the underlying display quality.","title":"setResolution(resolution)"},{"location":"graphics/#setorientationorientationorientation","text":"Ensure that the orientation of all Subpath s in this Graphics is the given orientation .","title":"setOrientation(orientation:Orientation)"},{"location":"graphics/#attributes","text":"paths gives you the Path s in this Graphics as a collection .","title":"Attributes"},{"location":"graphics/#types","text":"","title":"Types"},{"location":"graphics/#graphicssize","text":"\"copy\" \"auto\" (default) number","title":"GraphicsSize"},{"location":"graphics/#aabbprecision","text":"\"low\" \"high\" The latter computation will exactly estimate certain line extensions like miters, but it will be much slower.","title":"AABBPrecision"},{"location":"graphics/#displaymode","text":"\"texture\" \"mesh\" \"gpux\"","title":"DisplayMode"},{"location":"graphics/#orientation","text":"\"cw\" specifies clockwise orientation. \"ccw\" specifies counterclockwise orientation.","title":"Orientation"},{"location":"tesselators/","text":"Tesselators may be created using tove.newAdaptiveTesselator and tove.newRigidTesselator . Rigid Tesselators Rigid tesselators subdivide geometry using fixed steps and thus produce a fixed number of vertices. As an effect, all area of the geometry receive the same level of detail and subdivision. They are suited for animating meshes. Use tove.newRigidTesselator to create them. Adaptive Tesselators Adaptive Tesselators create a tesselation that gives more subdivision to areas where it's needed, whereas other areas might get less subdivision. The number of vertices produced by Adaptive Tesselators depends on the specific geometry. They are not suited for animation. Use tove.newAdaptiveTesselator to create them.","title":"Tesselators"},{"location":"tesselators/#rigid-tesselators","text":"Rigid tesselators subdivide geometry using fixed steps and thus produce a fixed number of vertices. As an effect, all area of the geometry receive the same level of detail and subdivision. They are suited for animating meshes. Use tove.newRigidTesselator to create them.","title":"Rigid Tesselators"},{"location":"tesselators/#adaptive-tesselators","text":"Adaptive Tesselators create a tesselation that gives more subdivision to areas where it's needed, whereas other areas might get less subdivision. The number of vertices produced by Adaptive Tesselators depends on the specific geometry. They are not suited for animation. Use tove.newAdaptiveTesselator to create them.","title":"Adaptive Tesselators"},{"location":"tutorials/Animation/","text":"Animating Things T\u00d6VE is designed for animating stuff. Its focus is not on static vector graphics rendering, but on animated vector graphics for games. Animating with the Stage API Many animations can be achieved by moving, rotating and scaling certain fixed parts of a graphics. T\u00d6VE offers the retained Stage API for simplifying these kind of animations. At the core is the Shape object. Each Shape holds a Graphics you can access. Each Shape knows about its own position, rotation and scale. You can change these at any time and they will stay this way across frames until you change them again. So if you have objects on the screen and only want to move some of them, Shape might simplify your code. For drawing, Shapes need to added to a Stage . Here's an example: local stage = tove.newStage() local shape = tove.newShape() shape.graphics:drawCircle(0, 0, 100) shape.graphics:setFillColor(0.7, 0.2, 0.3) shape.graphics:fill() -- add this shape to the stage. from now on -- it will get rendered with the stage. stage:addChild(shape) function love.draw() -- change the position of our shape. shape.x = love.mouse.getX() shape.y = love.mouse.getY() stage:draw() end Flipbooks and Animations Let's say you have a couple of SVGs that you want to play back like some sort of sprite sheet. T\u00d6VE has two kinds of API to support you with this. First, there are flipbooks. These are prerendered distinct frames. Think of a sprite atlas being played back. Seconds, there are animations. These are interpolated in real time, i.e. they are not prerendered. Note that for these, T\u00d6VE expects all frames to have exactly the same path layout (same number of trajectories and points across all frames). The \"blob\" demo has code for both animation styles. Tweens For both flipbooks and animations, the first thing to do is to create a tween that gathers all the keyframes and durations, much like a timeline in an animation program. Tweens can be created from Graphics or from SVG text data like this: svg1 = love.filesystem.read(\"frame1.svg\") svg2 = love.filesystem.read(\"frame2.svg\") tween = tove.newTween(svg1):to(svg2, 1) The code above creates a tween of two frames, where the second frame happens one second after the other. You can add more frames by calling to . So, tove.newTween(svg1):to(svg2, 1):to(svg3, 5) would create a tween that adds an additional frame 5 seconds after the second. to takes an optional third parameter which allows you to ease the transition. It expects a one-parameter Lua function that maps (0, 1). Flipbooks Flipbooks consist of distinct prerendered frames. That means flipbooks have high quality but only a discrete time resolution. Creating a flipbook is easy: f = tove.newFlipbook(8, tween) This creates a flipbook with 8 frames per second, i.e. it prerenders the tween at this frame rate. You can animate this flipbook by calling f:draw() and by setting f.t for its current time (in tween time, i.e. this is not a frame number). You can also specify what kind of renderer you want to use for the distinct frames. bitmap is the default, but you can also choose mesh which will prerender your frames as adaptive meshes. You can also specify quality settings as optional follow-up parameters. Animations Animations are frames interpolated and rendered in realtime. That means animations have a continuous time resolution but can also be expensive in terms of rendering. Animations are created like this: a = tove.newAnimation(tween, \"mesh\") As with flipbooks, you can use a:draw() to draw the current frame, and a.t to set the time. Looping By default, animations and flipbooks interpolate as if they bounce forth and back. If you want to look your animation, make sure to transition to the first frame at the end of the tween. This indicates to T\u00d6VE that you want a continuous interpolation from first to last: tween = tove.newTween(svg1):to(svg2, 1):to(svg1, 1) A Technical Note If you're using animations with a mesh renderer, T\u00d6VE will use a fixed resolution flattening and try to precalculate all triangulations. That means that the quality will be lower than for adaptive meshes, but things should be fast. Procedural Animation Features Sometimes you want even more flexibility for some kind of procedural animation: freely animate colors and gradients of a path in realtime freely animate a path by modifying its control points in realtime T\u00d6VE can do this. Take a look at the \"hearts\" demo to see working code. Here are some hints: The first step to animate colors or points is to tell your Graphics instance about it: call Graphics:setUsage to animate points (the shape of your drawing) or colors (the fill or stroke color of your drawing) or both. myDrawing:setUsage(\"points\", \"dynamic\") -- animate points myDrawing:setUsage(\"colors\", \"dynamic\") -- animate colors Without doing this, T\u00d6VE will not be able to animate your objects efficiently and things will be slow. Please note that T\u00d6VE does not efficiently support animations that add or delete points. Animating colors Animating colors is easy. Here are two examples: Animating by re-setting the color To animate the triangle from the Getting Started section, you could do this: function love.draw() local t = love.timer.getTime() -- current time local r, g, b = math.abs(math.sin(t)), 0.4, 0.2 myDrawing.paths[1]:setFillColor(tove.newColor(r, g, b)) end Note that we do not call setFillColor on the Graphics as that would only change the next new path we fill using Graphics:fill() . As we actively want to change the color of an already existing path, we need to grab that path using myDrawing.paths[1] . Of course, if you'd like the line color to change, you'd call setLineColor instead. Animating by changing the color A slightly different approach is changing the color itself: local myColor = tove.newColor() myDrawing.paths[1]:setFillColor(myColor) function love.draw() local r = math.abs(math.sin(love.timer.getTime())) myColor:set(r, 0.4, 0.2) RGB colors can be read and changed by either set(r, g, b, a) and r, g, b, a = get() or directly via attributes, e.g. someColor.r = 0.3 . So the code above could also be written as: local myColor = tove.newColor(0.0, 0.4, 0.2) myDrawing.paths[1]:setFillColor(myColor) function love.draw() myColor.r = math.abs(math.sin(love.timer.getTime())) A note on dependencies T\u00d6VE internally assumes that each object only has exactly one owner. For example, a color can only belong to one path; you cannot assign the same color to two paths, and then change it for both paths. As soon as you assign the same color to two paths, T\u00d6VE will internally clone one of the colors. So what will happen in the case above is that only one path (the one with the uncloned color) would change its color. The same holds true for trajectories and paths, and paths and graphics. Keep that in mind when working with many different objects. Animating shapes with Commands Most drawing calls come return a command, that allows you to animate what you have just drawn. An example: local shape = tove.newGraphics() shape.moveTo(10, 10) local myLineTo = shape.lineTo(100, 100) shape.moveTo(-50, 200) At any point later in your code, you can now modify the lineTo command: myLineTo.x = 200 This has the same effect as if you'd recreated the whole graphics with the modified lineTo , but it's much faster - using mutable commands, T\u00d6VE will animate stuff very efficiently (for example, for the mesh renderer, this boils down to a Mesh:setVertices call in L\u00d6VE). The attribute names are x and y for moveTo and lineTo . For curveTo you also have cp1x , cp1y , cp2x , cp2y . You can read and write those properties. Directly Accessing Paths and Curves Using Command is what you want to animate one path most of the time. Sometimes though want to have a broader access to your curve data. For example you might want to morph whole parts of a path. T\u00d6VE let's you do this. Let's first talk about how T\u00d6VE stores your curves and how it names things: A Graphics is a collection of Path s A Path is a collection of Subpath s (plus fill and stroke styles etc.) A Subpath consists of Curve s A Curve is a cubic bezier curve and consists of four control points With this scheme, you can access paths, subpaths and curves (all indices are 1-based): local myCurve = myGraphics.paths[1].subpaths[2].curves[5] Once you have picked a curve, you can modify its points by accessing its attributes x0 , y0 , cp1x , cp1y , cp2x , cp2y , x , y (the latter 6 correspond to the parameters you'd pass to Graphics:curveTo ). This works for reading and writing. For example, to animate the x target point of curve 1 of some graphics using your mouse, you might do this: function love.draw() myDrawing.paths[1].subpaths[1].curves[1].x = love.mouse.getX() myDrawing:Draw() end If you don't want to access curves, but the underlying points of all the subpath's curves as one continuous array, you can do it like this: myGraphics.paths[1].subpaths[2].points[3].x myGraphics.paths[1].subpaths[2].points[3].y To find out how many paths, subpaths, curves or points you have, you can use the count attribute, e.g.: myDrawing.paths.count -- number of paths myDrawing.paths[1].subpaths.count -- number of subpaths in path 1 myDrawing.paths[1].subpaths[1].points.count -- number of points in subpath 1 in path 1 Mesh Animation Caveats If you're using the mesh renderer for animation, there are two specific things that can cause problems: Clean, oriented curves. Usually, things should just work. If not, here are some hints. T\u00d6VE's automatically deals with obvious cases of point duplication (also during animation). Furthermore in dynamic points mesh mode, the default is to ignore orientation (i.e. no holes), which means your curve can be oriented in the wrong way and you will still see it. There might be situations where you want to clean or reorient your curves. T\u00d6VE offers two functions. Note that cleaning will get you into problems when animating paths that need to have exactly the same point layout. myGraphics:clean() myGraphics:setOrientation(\"ccw\") Triangulations. T\u00d6VE's animation system has a dynamic triangulation monitor that check whether it's current triangulation is still good or needs updating (which will usually happen due to sub shapes changing from convex to concave forms or vice versa). T\u00d6VE also caches triangulations and tries to reuse them. Still, with procedural animation and complete freedom, you might end up in situations where many retriangulations happen, which is expensive on the CPU. You can disable automatic retriangulation by calling myDrawing:setUsage(\"triangles\", \"static\") after calling myDrawing:setUsage(\"points\", \"dynamic\") (as the latter automatically always sets triangles to dynamic ). This means T\u00d6VE will stick with one triangulation (which can result in visual errors). If you do this, be sure to use graphics:cache() to pick one good triangulation at the beginning that you define as suitable for all animation frames.","title":"Animating Things"},{"location":"tutorials/Animation/#animating-things","text":"T\u00d6VE is designed for animating stuff. Its focus is not on static vector graphics rendering, but on animated vector graphics for games.","title":"Animating Things"},{"location":"tutorials/Animation/#animating-with-the-stage-api","text":"Many animations can be achieved by moving, rotating and scaling certain fixed parts of a graphics. T\u00d6VE offers the retained Stage API for simplifying these kind of animations. At the core is the Shape object. Each Shape holds a Graphics you can access. Each Shape knows about its own position, rotation and scale. You can change these at any time and they will stay this way across frames until you change them again. So if you have objects on the screen and only want to move some of them, Shape might simplify your code. For drawing, Shapes need to added to a Stage . Here's an example: local stage = tove.newStage() local shape = tove.newShape() shape.graphics:drawCircle(0, 0, 100) shape.graphics:setFillColor(0.7, 0.2, 0.3) shape.graphics:fill() -- add this shape to the stage. from now on -- it will get rendered with the stage. stage:addChild(shape) function love.draw() -- change the position of our shape. shape.x = love.mouse.getX() shape.y = love.mouse.getY() stage:draw() end","title":"Animating with the Stage API"},{"location":"tutorials/Animation/#flipbooks-and-animations","text":"Let's say you have a couple of SVGs that you want to play back like some sort of sprite sheet. T\u00d6VE has two kinds of API to support you with this. First, there are flipbooks. These are prerendered distinct frames. Think of a sprite atlas being played back. Seconds, there are animations. These are interpolated in real time, i.e. they are not prerendered. Note that for these, T\u00d6VE expects all frames to have exactly the same path layout (same number of trajectories and points across all frames). The \"blob\" demo has code for both animation styles.","title":"Flipbooks and Animations"},{"location":"tutorials/Animation/#tweens","text":"For both flipbooks and animations, the first thing to do is to create a tween that gathers all the keyframes and durations, much like a timeline in an animation program. Tweens can be created from Graphics or from SVG text data like this: svg1 = love.filesystem.read(\"frame1.svg\") svg2 = love.filesystem.read(\"frame2.svg\") tween = tove.newTween(svg1):to(svg2, 1) The code above creates a tween of two frames, where the second frame happens one second after the other. You can add more frames by calling to . So, tove.newTween(svg1):to(svg2, 1):to(svg3, 5) would create a tween that adds an additional frame 5 seconds after the second. to takes an optional third parameter which allows you to ease the transition. It expects a one-parameter Lua function that maps (0, 1).","title":"Tweens"},{"location":"tutorials/Animation/#flipbooks","text":"Flipbooks consist of distinct prerendered frames. That means flipbooks have high quality but only a discrete time resolution. Creating a flipbook is easy: f = tove.newFlipbook(8, tween) This creates a flipbook with 8 frames per second, i.e. it prerenders the tween at this frame rate. You can animate this flipbook by calling f:draw() and by setting f.t for its current time (in tween time, i.e. this is not a frame number). You can also specify what kind of renderer you want to use for the distinct frames. bitmap is the default, but you can also choose mesh which will prerender your frames as adaptive meshes. You can also specify quality settings as optional follow-up parameters.","title":"Flipbooks"},{"location":"tutorials/Animation/#animations","text":"Animations are frames interpolated and rendered in realtime. That means animations have a continuous time resolution but can also be expensive in terms of rendering. Animations are created like this: a = tove.newAnimation(tween, \"mesh\") As with flipbooks, you can use a:draw() to draw the current frame, and a.t to set the time.","title":"Animations"},{"location":"tutorials/Animation/#looping","text":"By default, animations and flipbooks interpolate as if they bounce forth and back. If you want to look your animation, make sure to transition to the first frame at the end of the tween. This indicates to T\u00d6VE that you want a continuous interpolation from first to last: tween = tove.newTween(svg1):to(svg2, 1):to(svg1, 1)","title":"Looping"},{"location":"tutorials/Animation/#a-technical-note","text":"If you're using animations with a mesh renderer, T\u00d6VE will use a fixed resolution flattening and try to precalculate all triangulations. That means that the quality will be lower than for adaptive meshes, but things should be fast.","title":"A Technical Note"},{"location":"tutorials/Animation/#procedural-animation-features","text":"Sometimes you want even more flexibility for some kind of procedural animation: freely animate colors and gradients of a path in realtime freely animate a path by modifying its control points in realtime T\u00d6VE can do this. Take a look at the \"hearts\" demo to see working code. Here are some hints: The first step to animate colors or points is to tell your Graphics instance about it: call Graphics:setUsage to animate points (the shape of your drawing) or colors (the fill or stroke color of your drawing) or both. myDrawing:setUsage(\"points\", \"dynamic\") -- animate points myDrawing:setUsage(\"colors\", \"dynamic\") -- animate colors Without doing this, T\u00d6VE will not be able to animate your objects efficiently and things will be slow. Please note that T\u00d6VE does not efficiently support animations that add or delete points.","title":"Procedural Animation Features"},{"location":"tutorials/Animation/#animating-colors","text":"Animating colors is easy. Here are two examples:","title":"Animating colors"},{"location":"tutorials/Animation/#animating-by-re-setting-the-color","text":"To animate the triangle from the Getting Started section, you could do this: function love.draw() local t = love.timer.getTime() -- current time local r, g, b = math.abs(math.sin(t)), 0.4, 0.2 myDrawing.paths[1]:setFillColor(tove.newColor(r, g, b)) end Note that we do not call setFillColor on the Graphics as that would only change the next new path we fill using Graphics:fill() . As we actively want to change the color of an already existing path, we need to grab that path using myDrawing.paths[1] . Of course, if you'd like the line color to change, you'd call setLineColor instead.","title":"Animating by re-setting the color"},{"location":"tutorials/Animation/#animating-by-changing-the-color","text":"A slightly different approach is changing the color itself: local myColor = tove.newColor() myDrawing.paths[1]:setFillColor(myColor) function love.draw() local r = math.abs(math.sin(love.timer.getTime())) myColor:set(r, 0.4, 0.2) RGB colors can be read and changed by either set(r, g, b, a) and r, g, b, a = get() or directly via attributes, e.g. someColor.r = 0.3 . So the code above could also be written as: local myColor = tove.newColor(0.0, 0.4, 0.2) myDrawing.paths[1]:setFillColor(myColor) function love.draw() myColor.r = math.abs(math.sin(love.timer.getTime()))","title":"Animating by changing the color"},{"location":"tutorials/Animation/#a-note-on-dependencies","text":"T\u00d6VE internally assumes that each object only has exactly one owner. For example, a color can only belong to one path; you cannot assign the same color to two paths, and then change it for both paths. As soon as you assign the same color to two paths, T\u00d6VE will internally clone one of the colors. So what will happen in the case above is that only one path (the one with the uncloned color) would change its color. The same holds true for trajectories and paths, and paths and graphics. Keep that in mind when working with many different objects.","title":"A note on dependencies"},{"location":"tutorials/Animation/#animating-shapes-with-commands","text":"Most drawing calls come return a command, that allows you to animate what you have just drawn. An example: local shape = tove.newGraphics() shape.moveTo(10, 10) local myLineTo = shape.lineTo(100, 100) shape.moveTo(-50, 200) At any point later in your code, you can now modify the lineTo command: myLineTo.x = 200 This has the same effect as if you'd recreated the whole graphics with the modified lineTo , but it's much faster - using mutable commands, T\u00d6VE will animate stuff very efficiently (for example, for the mesh renderer, this boils down to a Mesh:setVertices call in L\u00d6VE). The attribute names are x and y for moveTo and lineTo . For curveTo you also have cp1x , cp1y , cp2x , cp2y . You can read and write those properties.","title":"Animating shapes with Commands"},{"location":"tutorials/Animation/#directly-accessing-paths-and-curves","text":"Using Command is what you want to animate one path most of the time. Sometimes though want to have a broader access to your curve data. For example you might want to morph whole parts of a path. T\u00d6VE let's you do this. Let's first talk about how T\u00d6VE stores your curves and how it names things: A Graphics is a collection of Path s A Path is a collection of Subpath s (plus fill and stroke styles etc.) A Subpath consists of Curve s A Curve is a cubic bezier curve and consists of four control points With this scheme, you can access paths, subpaths and curves (all indices are 1-based): local myCurve = myGraphics.paths[1].subpaths[2].curves[5] Once you have picked a curve, you can modify its points by accessing its attributes x0 , y0 , cp1x , cp1y , cp2x , cp2y , x , y (the latter 6 correspond to the parameters you'd pass to Graphics:curveTo ). This works for reading and writing. For example, to animate the x target point of curve 1 of some graphics using your mouse, you might do this: function love.draw() myDrawing.paths[1].subpaths[1].curves[1].x = love.mouse.getX() myDrawing:Draw() end If you don't want to access curves, but the underlying points of all the subpath's curves as one continuous array, you can do it like this: myGraphics.paths[1].subpaths[2].points[3].x myGraphics.paths[1].subpaths[2].points[3].y To find out how many paths, subpaths, curves or points you have, you can use the count attribute, e.g.: myDrawing.paths.count -- number of paths myDrawing.paths[1].subpaths.count -- number of subpaths in path 1 myDrawing.paths[1].subpaths[1].points.count -- number of points in subpath 1 in path 1","title":"Directly Accessing Paths and Curves"},{"location":"tutorials/Animation/#mesh-animation-caveats","text":"If you're using the mesh renderer for animation, there are two specific things that can cause problems: Clean, oriented curves. Usually, things should just work. If not, here are some hints. T\u00d6VE's automatically deals with obvious cases of point duplication (also during animation). Furthermore in dynamic points mesh mode, the default is to ignore orientation (i.e. no holes), which means your curve can be oriented in the wrong way and you will still see it. There might be situations where you want to clean or reorient your curves. T\u00d6VE offers two functions. Note that cleaning will get you into problems when animating paths that need to have exactly the same point layout. myGraphics:clean() myGraphics:setOrientation(\"ccw\") Triangulations. T\u00d6VE's animation system has a dynamic triangulation monitor that check whether it's current triangulation is still good or needs updating (which will usually happen due to sub shapes changing from convex to concave forms or vice versa). T\u00d6VE also caches triangulations and tries to reuse them. Still, with procedural animation and complete freedom, you might end up in situations where many retriangulations happen, which is expensive on the CPU. You can disable automatic retriangulation by calling myDrawing:setUsage(\"triangles\", \"static\") after calling myDrawing:setUsage(\"points\", \"dynamic\") (as the latter automatically always sets triangles to dynamic ). This means T\u00d6VE will stick with one triangulation (which can result in visual errors). If you do this, be sure to use graphics:cache() to pick one good triangulation at the beginning that you define as suitable for all animation frames.","title":"Mesh Animation Caveats"},{"location":"tutorials/Demos/","text":"The Demos You might wonder at this point, what you gain with T\u00d6VE over simply rasterizing your vector graphics to textures via an export step from your vector drawing software. It's flexibility. Let's take a quick look at some of T\u00d6VE's demos , as they explain a lot about the core ideas and capabilities of T\u00d6VE. Running the Demos Check out the whole repo from GitHub. To run the demos, the lib and assets folders need to be accessible from inside the demos. On macOS and Linux, the demos contain symbolic links, and all you need to do is to unzip T\u00d6VE's lib into the repo's root like this: demos docs lib libTove.dylib ... LICENSE ... Then you can start one demo, e.g. the zoom demo, using: cd demos/zoom love . On Windows, the symbolic links don't work :-( So you need to unzip the lib into each demo folder. Also you need to copy the demos/assets folder inside the respective demo folder. Basically: replace the symlinks with the real stuff. MiniEdit Demo T\u00d6VE comes with a mini editor that lets you explore all of T\u00d6VE's features (different renderers and settings) interactively. You can drag and drop SVGs into the editor. It also has a demo mode that lets you benchmark performance: Zoom Demo Scaling bitmaps produces blurriness or pixelation, scaling meshes produces straight crisp lines, while T\u00d6VE's unique shader-based curves renderer will render crisp curves at many reasonable scales: Renderers Demo Interactively zoom T\u00d6VE's three renderers to inspect the quality: Tesselation Demo The mesh renderer's quality setting produces meshes of different detail and triangle count from the same SVG: Blob Demo Animate between two SVGs using different renderers and qualities: The SVGs have been exported as animation from one single timeline from Smith Micro Moho. As Moho uses one underlying geometry for all exported frame (defined on frame 1 in the timeline), all SVGs share the same path and point layout, which allows for interpolation in T\u00d6VE. Hearts Demo Procedurally animate geometry and colors (here: a linear gradient) through different renderers: The numbers displayed are times spent inside love.graphics.draw (might not be representative as more work might happen later in the swap of the GL context). The mesh and curves renderers update existing GPU data structures like meshes and shader textures without recreating them, which allows for higher frame rates. This demo also illustrates why the flatmesh renderer is called as it's called: you see that it's not able to handle gradients very well. Fill Rule Demo T\u00d6VE offers support for holes and fill rules for all of its renderers: Clip Path Demo For non-animated rendering, T\u00d6VE is able to render complex clip paths in texture and mesh modes:","title":"The Demos"},{"location":"tutorials/Demos/#the-demos","text":"You might wonder at this point, what you gain with T\u00d6VE over simply rasterizing your vector graphics to textures via an export step from your vector drawing software. It's flexibility. Let's take a quick look at some of T\u00d6VE's demos , as they explain a lot about the core ideas and capabilities of T\u00d6VE.","title":"The Demos"},{"location":"tutorials/Demos/#running-the-demos","text":"Check out the whole repo from GitHub. To run the demos, the lib and assets folders need to be accessible from inside the demos. On macOS and Linux, the demos contain symbolic links, and all you need to do is to unzip T\u00d6VE's lib into the repo's root like this: demos docs lib libTove.dylib ... LICENSE ... Then you can start one demo, e.g. the zoom demo, using: cd demos/zoom love . On Windows, the symbolic links don't work :-( So you need to unzip the lib into each demo folder. Also you need to copy the demos/assets folder inside the respective demo folder. Basically: replace the symlinks with the real stuff.","title":"Running the Demos"},{"location":"tutorials/Demos/#miniedit-demo","text":"T\u00d6VE comes with a mini editor that lets you explore all of T\u00d6VE's features (different renderers and settings) interactively. You can drag and drop SVGs into the editor. It also has a demo mode that lets you benchmark performance:","title":"MiniEdit Demo"},{"location":"tutorials/Demos/#zoom-demo","text":"Scaling bitmaps produces blurriness or pixelation, scaling meshes produces straight crisp lines, while T\u00d6VE's unique shader-based curves renderer will render crisp curves at many reasonable scales:","title":"Zoom Demo"},{"location":"tutorials/Demos/#renderers-demo","text":"Interactively zoom T\u00d6VE's three renderers to inspect the quality:","title":"Renderers Demo"},{"location":"tutorials/Demos/#tesselation-demo","text":"The mesh renderer's quality setting produces meshes of different detail and triangle count from the same SVG:","title":"Tesselation Demo"},{"location":"tutorials/Demos/#blob-demo","text":"Animate between two SVGs using different renderers and qualities: The SVGs have been exported as animation from one single timeline from Smith Micro Moho. As Moho uses one underlying geometry for all exported frame (defined on frame 1 in the timeline), all SVGs share the same path and point layout, which allows for interpolation in T\u00d6VE.","title":"Blob Demo"},{"location":"tutorials/Demos/#hearts-demo","text":"Procedurally animate geometry and colors (here: a linear gradient) through different renderers: The numbers displayed are times spent inside love.graphics.draw (might not be representative as more work might happen later in the swap of the GL context). The mesh and curves renderers update existing GPU data structures like meshes and shader textures without recreating them, which allows for higher frame rates. This demo also illustrates why the flatmesh renderer is called as it's called: you see that it's not able to handle gradients very well.","title":"Hearts Demo"},{"location":"tutorials/Demos/#fill-rule-demo","text":"T\u00d6VE offers support for holes and fill rules for all of its renderers:","title":"Fill Rule Demo"},{"location":"tutorials/Demos/#clip-path-demo","text":"For non-animated rendering, T\u00d6VE is able to render complex clip paths in texture and mesh modes:","title":"Clip Path Demo"},{"location":"tutorials/Getting_Started/","text":"Getting Started Some info to get you started. Installation To install T\u00d6VE, grab T\u00d6VE's binaries package and unzip it inside your L\u00d6VE project (as a folder called tove ). You should then be able to load T\u00d6VE using tove = require \"tove\" . T\u00d6VE's folder contains four files: init.lua : a Lua library binding to love libTove.dll : T\u00d6VE library (for Windows) libTove.dylib : T\u00d6VE library (for macOS) libTove.so : T\u00d6VE library (for Linux) Since you're running only on one platform, you'd only need one of the binary files, but they are all included for convenience. Drawing a Triangle Let's draw a triangle. First import T\u00d6VE as described above. Then create a Graphics instance, which is the main API for drawing in T\u00d6VE: local tove = require \"tove\" local myDrawing = tove.newGraphics() Graphics provides various functions of drawing and works similar to a canvas. Here comes our triangle: myDrawing:moveTo(100, 100) myDrawing:lineTo(200, 250) myDrawing:lineTo(50, 220) myDrawing:fill() moveTo moves your drawing brush to an absolute position. lineTo then draws two lines. fill finally tells T\u00d6VE to close the shape (i.e. supplement the missing third line) and fill it (with the current fill color). To see what we've drawn, we need to display the Graphics instance to the screen like this: function love.draw() myDrawing:draw() end Now you should see the image below; note that the coordinates you put into the moveTo and lineTo earlier correspond to the position of the triangle on L\u00d6VE screen. Wow, very impressive, no? Ok, you could indeed add some color by calling setFillColor before doing the fill : myDrawing:setFillColor(0.8, 0.4, 0.6) myDrawing:fill() Note: setFillColor can take RGBA values, but you can also specify HTML colors , e.g. setFillColor(#80AA20) . At this point, you might wonder what T\u00d6VE is about. All this can be done with L\u00d6VE as well. So on to the next section: Curves, lines and gradients While T\u00d6VE supports straight lines, curves are its real matter. Let's bend one side of our triangle by replacing the first lineTo from above with a curveTo , which will draw a cubic bezier curve: myDrawing:moveTo(100, 100) myDrawing:curveTo(120, 100, 210, 200, 200, 250) myDrawing:lineTo(50, 220) myDrawing:setFillColor(0.8, 0.4, 0.6) myDrawing:fill() curveTo takes the positions of two control points (x1, y1, x2, y2) and one target point (x, y). Together with the previous starting point this makes four points to define the cubic bezier curve. This is a good place to note that you can also use drawCircle(x, y, r) and drawEllipse(x, y, rx, ry) to draw circles and ellipses, and drawRect(x, y, w, h, rx, ry) to draw (rounded) rectangles. Let's continue with our triangle. Adding a bluish stroke of line width 10 is as simple as appending this code: myDrawing:setLineColor(0.2, 0.4, 0.6) myDrawing:setLineWidth(10) myDrawing:stroke() Now, instead of a solid purple fill, let's use a linear gradient to make things more interesting: local gradient = tove.newLinearGradient(120, 130, 140, 160) gradient:addColorStop(0, 0.8, 0.4, 0.6) gradient:addColorStop(1, 0.6, 0.2, 0.6) myDrawing:setFillColor(gradient) myDrawing:fill() Importing SVGs Yes, you can import SVGs, and it's as simple as this: local rabbit = love.filesystem.read(\"assets/rabbit.svg\") local myRabbit = tove.newGraphics(rabbit, 200) function love.draw() love.graphics.translate(250, 250) myRabbit:draw() end The call to newGraphics takes the actual SVG data that was loaded via love.filesystem.read . The optional second parameter, 200 , tells T\u00d6VE to prescale the graphics to 200 pixels. If this is omitted, the SVG's natural scaling will be used, which assumes you know its exact scaling. Note that after loading the SVG, T\u00d6VE no longer cares whether it's dealing with an SVG or a manually constructed graphics (meaning you can change the renderer and so on).","title":"Getting Started"},{"location":"tutorials/Getting_Started/#getting-started","text":"Some info to get you started.","title":"Getting Started"},{"location":"tutorials/Getting_Started/#installation","text":"To install T\u00d6VE, grab T\u00d6VE's binaries package and unzip it inside your L\u00d6VE project (as a folder called tove ). You should then be able to load T\u00d6VE using tove = require \"tove\" . T\u00d6VE's folder contains four files: init.lua : a Lua library binding to love libTove.dll : T\u00d6VE library (for Windows) libTove.dylib : T\u00d6VE library (for macOS) libTove.so : T\u00d6VE library (for Linux) Since you're running only on one platform, you'd only need one of the binary files, but they are all included for convenience.","title":"Installation"},{"location":"tutorials/Getting_Started/#drawing-a-triangle","text":"Let's draw a triangle. First import T\u00d6VE as described above. Then create a Graphics instance, which is the main API for drawing in T\u00d6VE: local tove = require \"tove\" local myDrawing = tove.newGraphics() Graphics provides various functions of drawing and works similar to a canvas. Here comes our triangle: myDrawing:moveTo(100, 100) myDrawing:lineTo(200, 250) myDrawing:lineTo(50, 220) myDrawing:fill() moveTo moves your drawing brush to an absolute position. lineTo then draws two lines. fill finally tells T\u00d6VE to close the shape (i.e. supplement the missing third line) and fill it (with the current fill color). To see what we've drawn, we need to display the Graphics instance to the screen like this: function love.draw() myDrawing:draw() end Now you should see the image below; note that the coordinates you put into the moveTo and lineTo earlier correspond to the position of the triangle on L\u00d6VE screen. Wow, very impressive, no? Ok, you could indeed add some color by calling setFillColor before doing the fill : myDrawing:setFillColor(0.8, 0.4, 0.6) myDrawing:fill() Note: setFillColor can take RGBA values, but you can also specify HTML colors , e.g. setFillColor(#80AA20) . At this point, you might wonder what T\u00d6VE is about. All this can be done with L\u00d6VE as well. So on to the next section:","title":"Drawing a Triangle"},{"location":"tutorials/Getting_Started/#curves-lines-and-gradients","text":"While T\u00d6VE supports straight lines, curves are its real matter. Let's bend one side of our triangle by replacing the first lineTo from above with a curveTo , which will draw a cubic bezier curve: myDrawing:moveTo(100, 100) myDrawing:curveTo(120, 100, 210, 200, 200, 250) myDrawing:lineTo(50, 220) myDrawing:setFillColor(0.8, 0.4, 0.6) myDrawing:fill() curveTo takes the positions of two control points (x1, y1, x2, y2) and one target point (x, y). Together with the previous starting point this makes four points to define the cubic bezier curve. This is a good place to note that you can also use drawCircle(x, y, r) and drawEllipse(x, y, rx, ry) to draw circles and ellipses, and drawRect(x, y, w, h, rx, ry) to draw (rounded) rectangles. Let's continue with our triangle. Adding a bluish stroke of line width 10 is as simple as appending this code: myDrawing:setLineColor(0.2, 0.4, 0.6) myDrawing:setLineWidth(10) myDrawing:stroke() Now, instead of a solid purple fill, let's use a linear gradient to make things more interesting: local gradient = tove.newLinearGradient(120, 130, 140, 160) gradient:addColorStop(0, 0.8, 0.4, 0.6) gradient:addColorStop(1, 0.6, 0.2, 0.6) myDrawing:setFillColor(gradient) myDrawing:fill()","title":"Curves, lines and gradients"},{"location":"tutorials/Getting_Started/#importing-svgs","text":"Yes, you can import SVGs, and it's as simple as this: local rabbit = love.filesystem.read(\"assets/rabbit.svg\") local myRabbit = tove.newGraphics(rabbit, 200) function love.draw() love.graphics.translate(250, 250) myRabbit:draw() end The call to newGraphics takes the actual SVG data that was loaded via love.filesystem.read . The optional second parameter, 200 , tells T\u00d6VE to prescale the graphics to 200 pixels. If this is omitted, the SVG's natural scaling will be used, which assumes you know its exact scaling. Note that after loading the SVG, T\u00d6VE no longer cares whether it's dealing with an SVG or a manually constructed graphics (meaning you can change the renderer and so on).","title":"Importing SVGs"},{"location":"tutorials/Renderers/","text":"Setting Renderers This section should give you some idea of why there are three different renderers in T\u00d6VE, what they do, and when you want to change things. The renderers T\u00d6VE provides three renderers to bring vector graphics to the screen: texture , mesh and shader : texture is the default renderer. It gives high quality and high performance for static images that don't need animation or scaling. Internally, this is NanoSVG rendering to a texture. mesh uses a triangle mesh to produce a tessellated version of the graphics, which is then drawn using a L\u00d6VE Mesh. Scaling will not produce pixelation, but crisp straight edges. Using this renderer, curves and colors can be animated efficiently. shader is a purely shader-based renderer that gives high quality at different resolutions. It's a very complex shader and highly experimental. It allows for efficient animation of curves and colors. You can tell T\u00d6VE which renderer to use by calling Graphics:setDisplay(mode, quality) on your Graphics instance, e.g. myDrawing:setDisplay(\"mesh\") . The next call to Graphics:draw() will then honor that setting. The optional quality parameter is a render-dependent number that allows you to configure the level of detail for some renderers. Let's try this out. With the curved triangle from the Getting Started section, let's set a mesh renderer before drawing: myDrawing:setDisplay(\"mesh\") function love.draw() myDrawing:draw() end You might notice that the bottom right edge looks a bit edgy now. That's due to the mesh's default quality setting. To see that we're really dealing with a mesh, let's increase that effect by telling T\u00d6VE to use even less triangles: myDrawing:setDisplay(\"mesh\", 100) -- specify the target resolution in pixels to define tesselation detail One of the strengths of T\u00d6VE is that choosing the display renderer is independent of building your geometry and colors. Which renderer is right for me? Here are some hints: texture gives great quality, but is slow for re-rendering and scaling via transforms will produce pixelation, unless you re-render for a higher resolution. You can tell T\u00d6VE at which resolution to render internally by using Graphics:setResolution (this won't affect the display size, but you'll see that a resolution of 2 will allow you to scale the image by a factor of 2 without seeing pixelation). mesh is the best all-round solution if you need to dynamically scale your graphics. Once you determine a detail level that matches your requirements (in terms of scaling and zoom), you're basically dealing with a L\u00d6VE Mesh, which is efficient to draw, scale and animate. shader can give excellent results in terms of quality and performance in some situations. Then again, it can be very expensive in terms of shader performance and it has some issues with numerical stability (computing cubic roots in a shader using 16 bit floating point numbers is not only potty but indeed has its limits). Setting the mesh renderer quality The quality setting in Graphics:setDisplay lets you change the level of the detail the mesh renderer tessellates its mesh. There are two meanings of this values, depending on whether your points are static or dynamic (see the section on Animating Things). If your points are static (default), the quality is a number between 0 and 1, where 1 is the highest suggested quality (though you can go above 1). The renderer will produce an adaptive mesh tessellation, where some curves get many points and others (e.g. straight lines) few. Values below 0.1 trigger a special low quality tier that tries to produce a minimum of triangles. If your points are dynamic (for animation), the quality is also a number between 0 and 1, but 0 now corresponds to 0 fixed subdivisions per curve, whereas 1 corresponds to a fixed subdivision of 16 segments per curve. In short: your quality is no longer adaptive. In addition, you can always force fixed subdivision by specifying tove.fixed(n) as quality: each curve will then be segmented into exactly 2^n parts. Use this if you don't want adaptive subdivision for static point meshes. The second factor to mention here is the value set via Graphics:setResolution . T\u00d6VE internally scales meshes before applying the quality settings. That means that setting a higher resolution will yield a higher quality with the same quality number. Imagine rendering the same image at a higher resolution and then scaling it down again for display. This is the effect you get by calling setResolution on meshes. The mesh renderer and gradients The mesh renderer automatically detects if you are using gradients or not. If not, it internally uses a flat mesh of vertices and colors. If you use gradients, it will use a shader implementation for the coloring.","title":"Setting Renderers"},{"location":"tutorials/Renderers/#setting-renderers","text":"This section should give you some idea of why there are three different renderers in T\u00d6VE, what they do, and when you want to change things.","title":"Setting Renderers"},{"location":"tutorials/Renderers/#the-renderers","text":"T\u00d6VE provides three renderers to bring vector graphics to the screen: texture , mesh and shader : texture is the default renderer. It gives high quality and high performance for static images that don't need animation or scaling. Internally, this is NanoSVG rendering to a texture. mesh uses a triangle mesh to produce a tessellated version of the graphics, which is then drawn using a L\u00d6VE Mesh. Scaling will not produce pixelation, but crisp straight edges. Using this renderer, curves and colors can be animated efficiently. shader is a purely shader-based renderer that gives high quality at different resolutions. It's a very complex shader and highly experimental. It allows for efficient animation of curves and colors. You can tell T\u00d6VE which renderer to use by calling Graphics:setDisplay(mode, quality) on your Graphics instance, e.g. myDrawing:setDisplay(\"mesh\") . The next call to Graphics:draw() will then honor that setting. The optional quality parameter is a render-dependent number that allows you to configure the level of detail for some renderers. Let's try this out. With the curved triangle from the Getting Started section, let's set a mesh renderer before drawing: myDrawing:setDisplay(\"mesh\") function love.draw() myDrawing:draw() end You might notice that the bottom right edge looks a bit edgy now. That's due to the mesh's default quality setting. To see that we're really dealing with a mesh, let's increase that effect by telling T\u00d6VE to use even less triangles: myDrawing:setDisplay(\"mesh\", 100) -- specify the target resolution in pixels to define tesselation detail One of the strengths of T\u00d6VE is that choosing the display renderer is independent of building your geometry and colors.","title":"The renderers"},{"location":"tutorials/Renderers/#which-renderer-is-right-for-me","text":"Here are some hints: texture gives great quality, but is slow for re-rendering and scaling via transforms will produce pixelation, unless you re-render for a higher resolution. You can tell T\u00d6VE at which resolution to render internally by using Graphics:setResolution (this won't affect the display size, but you'll see that a resolution of 2 will allow you to scale the image by a factor of 2 without seeing pixelation). mesh is the best all-round solution if you need to dynamically scale your graphics. Once you determine a detail level that matches your requirements (in terms of scaling and zoom), you're basically dealing with a L\u00d6VE Mesh, which is efficient to draw, scale and animate. shader can give excellent results in terms of quality and performance in some situations. Then again, it can be very expensive in terms of shader performance and it has some issues with numerical stability (computing cubic roots in a shader using 16 bit floating point numbers is not only potty but indeed has its limits).","title":"Which renderer is right for me?"},{"location":"tutorials/Renderers/#setting-the-mesh-renderer-quality","text":"The quality setting in Graphics:setDisplay lets you change the level of the detail the mesh renderer tessellates its mesh. There are two meanings of this values, depending on whether your points are static or dynamic (see the section on Animating Things). If your points are static (default), the quality is a number between 0 and 1, where 1 is the highest suggested quality (though you can go above 1). The renderer will produce an adaptive mesh tessellation, where some curves get many points and others (e.g. straight lines) few. Values below 0.1 trigger a special low quality tier that tries to produce a minimum of triangles. If your points are dynamic (for animation), the quality is also a number between 0 and 1, but 0 now corresponds to 0 fixed subdivisions per curve, whereas 1 corresponds to a fixed subdivision of 16 segments per curve. In short: your quality is no longer adaptive. In addition, you can always force fixed subdivision by specifying tove.fixed(n) as quality: each curve will then be segmented into exactly 2^n parts. Use this if you don't want adaptive subdivision for static point meshes. The second factor to mention here is the value set via Graphics:setResolution . T\u00d6VE internally scales meshes before applying the quality settings. That means that setting a higher resolution will yield a higher quality with the same quality number. Imagine rendering the same image at a higher resolution and then scaling it down again for display. This is the effect you get by calling setResolution on meshes.","title":"Setting the mesh renderer quality"},{"location":"tutorials/Renderers/#the-mesh-renderer-and-gradients","text":"The mesh renderer automatically detects if you are using gradients or not. If not, it internally uses a flat mesh of vertices and colors. If you use gradients, it will use a shader implementation for the coloring.","title":"The mesh renderer and gradients"}]}