--  This file has been autogenerated. DO NOT CHANGE IT.
--

--[[
*****************************************************************
TÖVE - Animated vector graphics for LÖVE.
https://github.com/poke1024/tove2d

Copyright (c) 2018, Bernhard Liebl

Distributed under the MIT license. See LICENSE file for details.

All rights reserved.
*****************************************************************
]]--

local ffi = require 'ffi'

ffi.cdef [[
typedef uint32_t ToveChangeFlags;

typedef uint32_t ToveMeshUpdateFlags;

typedef enum {
	ERR_NONE = 0,
	ERR_TRIANGULATION_FAILED,
	ERR_OUT_OF_MEMORY,
	ERR_UNKNOWN
} ToveError;

typedef struct {
	ToveError err;
	ToveMeshUpdateFlags update;
} ToveMeshResult;

typedef struct {
	float *array;
	int n;
} ToveFloatArray;

typedef struct {
	uint8_t *array;
	int n;
} ToveColorArray;

typedef struct {
	uint16_t *array;
	int n;
} ToveIndex16Array;

typedef struct {
	uint8_t *pixels;
} ToveImageRecord;

void DeleteImage(ToveImageRecord image);

typedef enum {
	PAINT_UNDEFINED = -1,
	PAINT_NONE = 0,
	PAINT_SOLID = 1,
	PAINT_LINEAR_GRADIENT = 2,
	PAINT_RADIAL_GRADIENT = 3
} TovePaintType;

typedef enum {
	FILLRULE_NON_ZERO = 0,
	FILLRULE_EVEN_ODD = 1
} ToveFillRule;

typedef enum {
	ORIENTATION_CW = 0,
	ORIENTATION_CCW = 1
} ToveOrientation;

enum {
	CHANGED_FILL_STYLE = 1,
	CHANGED_LINE_STYLE = 2,
	CHANGED_POINTS = 4,
	CHANGED_GEOMETRY = 8,
	CHANGED_RECREATE = 128,
	CHANGED_ANYTHING = 255
};

enum {
	UPDATE_MESH_VERTICES = 1,
	UPDATE_MESH_COLORS = 2,
	UPDATE_MESH_TRIANGLES = 4,
	UPDATE_MESH_EVERYTHING = 7,
	UPDATE_MESH_AUTO_TRIANGLES = 128
};

typedef struct {
	float x, y;
} TovePoint;

typedef struct {
	void *ptr;
} TovePaintRef;

typedef struct {
	void *ptr;
} ToveTrajectoryRef;

typedef struct {
	void *ptr;
} ToveCommandRef;

typedef struct {
	void *ptr;
} TovePathRef;

typedef struct {
	void *ptr;
} ToveGraphicsRef;

typedef struct {
	int recursionLimit;
	struct {
		bool valid;
		float distanceTolerance;
		float colinearityEpsilon;
		float angleEpsilon;
		float angleTolerance;
		float cuspLimit;
	} adaptive;
} ToveTesselationQuality;

typedef struct {
	float r, g, b, a;
} RGBA;

typedef struct {
	float x0, y0, x1, y1;
} ToveBounds;

typedef float ToveMatrix3x3[9];

typedef struct {
	ToveMatrix3x3 matrix;
	uint8_t *colorsTexture;
	int colorsTextureRowBytes;
} ToveShaderGradientData;

typedef struct {
	ToveShaderGradientData *data;
	int numColors;
} ToveShaderGradient;

typedef struct {
	int8_t style; // TovePaintType
	RGBA rgba;
	ToveShaderGradient gradient;
} ToveShaderColorData;

typedef struct {
	int numCurves;
	float bounds[4];
	float strokeWidth;
	int8_t fillRule;

	float *lookupTable;
	int lookupTableSize;
	int lookupTableFill[2];

	uint8_t *listsTexture;
	int listsTextureRowBytes;
	int listsTextureSize[2];
	const char *listsTextureFormat;

	uint16_t *curvesTexture;
	int curvesTextureRowBytes;
	int curvesTextureSize[2];
	const char *curvesTextureFormat;
} ToveShaderGeometryData;

typedef struct {
	ToveShaderColorData line;
	ToveShaderColorData fill;
} ToveShaderLineFillColorData;

typedef struct {
	ToveShaderLineFillColorData color;
	ToveShaderGeometryData geometry;
} ToveShaderData;

typedef struct {
	void *ptr;
} ToveShaderLinkRef;

typedef struct {
	void *ptr;
} ToveMeshRef;

const char *GetVersion();

TovePaintType PaintGetType(TovePaintRef paint);
TovePaintRef ClonePaint(TovePaintRef paint);
TovePaintRef NewColor(float r, float g, float b, float a);
void ColorSet(TovePaintRef color, float r, float g, float b, float a);
RGBA ColorGet(TovePaintRef color, float opacity);
TovePaintRef NewLinearGradient(float x1, float y1, float x2, float y2);
TovePaintRef NewRadialGradient(float cx, float cy, float fx, float fy, float r);
void GradientAddColorStop(TovePaintRef gradient, float offset, float r, float g, float b, float a);
void GradientSetColorStop(TovePaintRef gradient, int i, float offset, float r, float g, float b, float a);
void ReleasePaint(TovePaintRef color);

ToveTrajectoryRef NewTrajectory();
ToveTrajectoryRef CloneTrajectory(ToveTrajectoryRef trajectory);
int TrajectoryGetNumCurves(ToveTrajectoryRef trajectory);
int TrajectoryGetNumPoints(ToveTrajectoryRef trajectory);
const float *TrajectoryGetPoints(ToveTrajectoryRef trajectory);
void TrajectorySetPoint(ToveTrajectoryRef trajectory, int index, float x, float y);
void TrajectorySetPoints(ToveTrajectoryRef trajectory, const float *pts, int npts);
float TrajectoryGetValue(ToveTrajectoryRef trajectory, int index);
void TrajectorySetValue(ToveTrajectoryRef trajectory, int index, float value);
void TrajectoryInvert(ToveTrajectoryRef trajectory);
void TrajectorySetOrientation(ToveTrajectoryRef trajectory, ToveOrientation orientation);
void TrajectoryClean(ToveTrajectoryRef trajectory, float eps);
int TrajectoryMoveTo(ToveTrajectoryRef trajectory, float x, float y);
int TrajectoryLineTo(ToveTrajectoryRef trajectory, float x, float y);
int TrajectoryCurveTo(ToveTrajectoryRef trajectory, float cpx1, float cpy1, float cpx2, float cpy2, float x, float y);
int TrajectoryArc(ToveTrajectoryRef trajectory, float x, float y, float r, float startAngle, float endAngle, bool counterclockwise);
int TrajectoryDrawRect(ToveTrajectoryRef trajectory, float x, float y, float w, float h, float rx, float ry);
int TrajectoryDrawEllipse(ToveTrajectoryRef trajectory, float x, float y, float rx, float ry);
float TrajectoryGetCommandValue(ToveTrajectoryRef trajectory, int command, int property);
void TrajectorySetCommandValue(ToveTrajectoryRef trajectory, int command, int property, float value);
void ReleaseTrajectory(ToveTrajectoryRef trajectory);

TovePathRef NewPath(const char *d);
TovePathRef ClonePath(TovePathRef path);
ToveTrajectoryRef PathBeginTrajectory(TovePathRef path);
void PathAddTrajectory(TovePathRef path, ToveTrajectoryRef traj);
void PathSetFillColor(TovePathRef path, TovePaintRef color);
void PathSetLineColor(TovePathRef path, TovePaintRef color);
TovePaintRef PathGetFillColor(TovePathRef path);
TovePaintRef PathGetLineColor(TovePathRef path);
void PathSetLineWidth(TovePathRef path, float width);
void PathSetLineDash(TovePathRef path, const float *dashes, int count);
void PathSetLineDashOffset(TovePathRef path, float offset);
float PathGetLineWidth(TovePathRef path);
int PathGetNumTrajectories(TovePathRef path);
ToveTrajectoryRef PathGetTrajectory(TovePathRef path, int i);
void PathAnimate(TovePathRef path, TovePathRef a, TovePathRef b, float t);
int PathGetNumCurves(TovePathRef path);
ToveFillRule PathGetFillRule(TovePathRef path);
void PathSetFillRule(TovePathRef path, ToveFillRule rule);
float PathGetOpacity(TovePathRef path);
void PathSetOpacity(TovePathRef path, float opacity);
void PathClearChanges(TovePathRef path);
ToveMeshResult PathTesselate(TovePathRef path, ToveMeshRef fillMesh, ToveMeshRef lineMesh, float scale, const ToveTesselationQuality *quality, ToveMeshUpdateFlags flags);
ToveChangeFlags PathFetchChanges(TovePathRef path, ToveChangeFlags flags);
void PathSetOrientation(TovePathRef path, ToveOrientation orientation);
void PathClean(TovePathRef path, float eps);
void ReleasePath(TovePathRef path);

ToveGraphicsRef NewGraphics(const char *svg, const char* units, float dpi);
ToveGraphicsRef CloneGraphics(ToveGraphicsRef graphics);
ToveTrajectoryRef GraphicsBeginTrajectory(ToveGraphicsRef graphics);
void GraphicsCloseTrajectory(ToveGraphicsRef graphics);
TovePathRef GraphicsGetCurrentPath(ToveGraphicsRef shape);
void GraphicsAddPath(ToveGraphicsRef shape, TovePathRef path);
int GraphicsGetNumPaths(ToveGraphicsRef shape);
TovePathRef GraphicsGetPath(ToveGraphicsRef shape, int i);
ToveChangeFlags GraphicsFetchChanges(ToveGraphicsRef shape, ToveChangeFlags flags);
void GraphicsSetFillColor(ToveGraphicsRef shape, TovePaintRef color);
void GraphicsSetLineColor(ToveGraphicsRef shape, TovePaintRef color);
void GraphicsSetLineWidth(ToveGraphicsRef shape, float width);
void GraphicsSetLineDash(ToveGraphicsRef shape, const float *dashes, int count);
void GraphicsSetLineDashOffset(ToveGraphicsRef shape, float offset);
void GraphicsFill(ToveGraphicsRef shape);
void GraphicsStroke(ToveGraphicsRef shape);
ToveBounds GraphicsGetBounds(ToveGraphicsRef shape);
void GraphicsTransform(ToveGraphicsRef shape, float sx, float sy, float tx, float ty);
ToveMeshResult GraphicsTesselate(ToveGraphicsRef shape, ToveMeshRef mesh, float scale, const ToveTesselationQuality *quality, ToveMeshUpdateFlags flags);
ToveImageRecord GraphicsRasterize(ToveGraphicsRef shape, int width, int height, float tx, float ty, float scale, const ToveTesselationQuality *quality);
void GraphicsAnimate(ToveGraphicsRef shape, ToveGraphicsRef a, ToveGraphicsRef b, float t);
void GraphicsSetOrientation(ToveGraphicsRef shape, ToveOrientation orientation);
void GraphicsClean(ToveGraphicsRef shape, float eps);
void ReleaseGraphics(ToveGraphicsRef shape);

ToveShaderLinkRef NewShaderLink(int numCurves);
ToveChangeFlags ShaderLinkBeginUpdate(ToveShaderLinkRef link, TovePathRef path, bool initial);
ToveChangeFlags ShaderLinkEndUpdate(ToveShaderLinkRef link, TovePathRef path, bool initial);
ToveShaderData *ShaderLinkGetData(ToveShaderLinkRef link);
ToveShaderLineFillColorData *ShaderLinkGetColorData(ToveShaderLinkRef link);
void ReleaseShaderLink(ToveShaderLinkRef link);

ToveMeshRef NewMesh();
ToveMeshRef NewColorMesh();
ToveFloatArray MeshGetVertices(ToveMeshRef mesh);
ToveColorArray MeshGetColors(ToveMeshRef mesh);
ToveIndex16Array MeshGetIndices(ToveMeshRef mesh);
void ReleaseMesh(ToveMeshRef mesh);
]]

tove = {}

tove.init = function(path)
	local libName = {
		["OS X"] = "libTove.dylib",
		["Windows"] = "tove.dll",
		["Linux"] = "tove.so"
	}

	local basepath = debug.getinfo(2, "S").source:sub(2):match("(.*/)")

	local lib = ffi.load(basepath .. libName[love.system.getOS()])
	tove.lib = lib
	tove.getVersion = lib.GetVersion

	local _attributes = {
		cp1x = 0,
		cp1y = 1,
		cp2x = 2,
		cp2y = 3,
		x = 4,
		y = 5,
		x0 = -2,
		y0 = -1,

		w = 6,
		h = 7,

		cx = 100,
		cy = 101,
		rx = 102,
		ry = 103,
		r = 104,
	}

	local function totable(u, n)
		local t = {}
		for i = 1, n do
			t[i] = u[i - 1]
		end
		return t
	end

	local bit = require("bit")

local Paint = (function()

local _attr = {r = 1, g = 2, b = 3, a = 4}

local Paint = {}
Paint.__index = function (self, key)
	if _attr[key] ~= nil then
		local rgba = lib.ColorGet(self._ref, 1)
		return rgba[key]
	else
		return Paint[key]
	end
end
Paint.__newindex = function(self, key, value)
	local i = _attr[key]
	if i ~= nil then
		local rgba = {self:get()}
		rgba[i] = value
		self:set(unpack(rgba))
	end
end

local function fromRef(ref)
	if ref.ptr == nil then
		return nil
	else
		return setmetatable({_ref = ffi.gc(ref, lib.ReleasePaint)}, Paint)
	end
end

Paint._fromRef = fromRef

local newColor = function(r, g, b, a)
	return fromRef(lib.NewColor(r or 0, g or 0, b or 0, a or 1))
end

tove.newColor = newColor

tove.newLinearGradient = function(x0, y0, x1, y1)
	return fromRef(lib.NewLinearGradient(x0, y0, x1, y1))
end

tove.newRadialGradient = function(cx, cy, fx, fy, r)
	return fromRef(lib.NewRadialGradient(cx, cy, fx, fy, r))
end

function Paint:get(opacity)
	local rgba = lib.ColorGet(self._ref, opacity or 1)
	return rgba.r, rgba.g, rgba.b, rgba.a
end

function Paint:set(r, g, b, a)
	lib.ColorSet(self._ref, r, g, b, a or 1)
end

function Paint:addColorStop(offset, r, g, b, a)
	lib.GradientAddColorStop(self._ref, offset, r, g, b, a or 1)
end

function Paint:clone()
	return lib.ClonePaint(self._ref)
end

Paint._wrap = function(r, g, b, a)
	if getmetatable(r) == Paint then
		return r
	end
	local t = type(r)
	if t == "number" then
		return newColor(r, g, b, a)
	elseif t == "string" and r:sub(1, 1) == '#' then
		r = r:gsub("#","")
		return newColor(
			tonumber("0x" .. r:sub(1, 2)) / 255,
			tonumber("0x" .. r:sub(3, 4)) / 255,
			tonumber("0x" .. r:sub(5, 6)) / 255)
	else
		error("tove: cannot parse color: " .. tostring(r))
	end
end

return Paint
end)()
local newCommand = (function()

local Command = {}
Command.__index = function (self, key)
	return lib.TrajectoryGetCommandValue(self._t, self._c, _attributes[key])
end
Command.__newindex = function (self, key, value)
	lib.TrajectorySetCommandValue(rawget(self, "_t"), rawget(self, "_c"), _attributes[key], value)
end

return function(trajectory, command)
	return setmetatable({_t = trajectory, _c = command}, Command)
end
end)()
local Trajectory = (function()

local Curve = {}
Curve.__index = function (self, key)
	return lib.TrajectoryGetValue(self.traj, self.i + _attributes[key])
end
Curve.__newindex = function (self, key, value)
	return lib.TrajectorySetValue(self.traj, self.i + _attributes[key], value)
end

local Curves = {}
Curves.__index = function (self, index)
	return setmetatable({traj = self.traj, i = 2 + (index - 1) * 6}, Curve)
end

local Points = {}
Points.__index = function (self, i)
	local n = lib.TrajectoryGetNumPoints(self.traj)
	if i < 1 or i > n then
		return nil
	end
	i = i - 1
	local p = lib.TrajectoryGetPoints(self.traj)
	return {x = p[2 * i + 0], y = p[2 * i + 1]}
end

local Trajectory = {}
Trajectory.__index = function (self, key)
	if key == "curves" then
		return setmetatable({traj = self}, Curves)
	elseif key == "ncurves" then
		return lib.TrajectoryGetNumCurves(self)
	elseif key == "points" then
		return setmetatable({traj = self}, Points)
	elseif key == "npoints" then
		return lib.TrajectoryGetNumPoints(self)
	else
		return Trajectory[key]
	end
end

function Trajectory:setPoints(t, n)
	lib.TrajectorySetPoints(self, t, n)
end

ffi.metatype("ToveTrajectoryRef", Trajectory)

tove.newTrajectory = function()
	return ffi.gc(lib.NewTrajectory(), lib.ReleaseTrajectory)
end

return Trajectory
end)()
local Path = (function()

local Trajectories = {}
Trajectories.__index = function (self, i)
	return ffi.gc(lib.PathGetTrajectory(self.path, i), lib.ReleaseTrajectory)
end

local Path = {}
Path.__index = function (path, key)
	if key == "trajs" then
		return setmetatable({path = path}, Trajectories)
	elseif key == "ntrajs" then
		return lib.PathGetNumTrajectories(path)
	else
		return Path[key]
	end
end

Path.clone = lib.ClonePath
Path.setLineDashOffset = lib.PathSetLineDashOffset
Path.getLineWidth = lib.PathGetLineWidth
Path.setLineWidth = lib.PathSetLineWidth
Path.getNumCurves = lib.PathGetNumCurves
Path.getOpacity = lib.PathGetOpacity
Path.setOpacity = lib.PathSetOpacity
Path.clearChanges = lib.PathClearChanges
Path.fetchChanges = lib.PathFetchChanges

function Path:beginTrajectory()
	return fii.gc(lib.PathBeginTrajectory(self), lib.ReleaseTrajectory)
end

function Path:addTrajectory(t)
	lib.PathAddTrajectory(self, t)
end

function Path:moveTo(x, y)
	lib.TrajectoryMoveTo(self:beginTrajectory(), x, y)
end

function Path:lineTo(x, y)
	lib.TrajectoryLineTo(self:beginTrajectory(), x, y)
end

function Path:curveTo(...)
	lib.TrajectorCurveTo(self:beginTrajectory(), ...)
end

function Path:getFillColor()
	return Paint._fromRef(lib.PathGetFillColor(self))
end

function Path:getLineColor()
	return Paint._fromRef(lib.PathGetLineColor(self))
end

function Path:setFillColor(r, g, b, a)
	lib.PathSetFillColor(self, Paint._wrap(r, g, b, a)._ref)
end

function Path:setLineColor(r, g, b, a)
	lib.PathSetLineColor(self, Paint._wrap(r, g, b, a)._ref)
end

local _fillrule = {
	nonzero = lib.FILLRULE_NON_ZERO,
	evenodd = lib.FILLRULE_EVEN_ODD
}

function Path:setFillRule(rule)
	lib.PathSetFillRule(self, _fillrule[rule])
end

function Path:animate(a, b, t)
	lib.PathAnimate(self, a, b, t)
end

ffi.metatype("TovePathRef", Path)

tove.newPath = function(d)
	return ffi.gc(lib.NewPath(d), lib.ReleasePath)
end

return Path
end)()

local _mesh = (function()

local PositionMesh = {}
PositionMesh.__index = PositionMesh

tove.newPositionMesh = function(usage)
	return setmetatable({_cmesh = ffi.gc(lib.NewMesh(), lib.ReleaseMesh),
		_mesh = nil, _usage = usage or {}}, PositionMesh)
end

function PositionMesh:getUsage(what)
	return self._usage[what]
end

function PositionMesh:updateVertices()
	cvertices = lib.MeshGetVertices(self._cmesh)

	local vertices = {}
	local positions = cvertices.array
	local pi = 0
	for i = 1, cvertices.n do
		vertices[i] = {positions[pi + 0], positions[pi + 1],
			positions[pi + 0], positions[pi + 1]}
		pi = pi + 2
	end

	local mesh = self._mesh
	if mesh ~= nil then
		mesh:setVertices(vertices)
	end
end

function PositionMesh:updateTriangles()
	local mesh = self._mesh
	if mesh ~= nil then
		ctriangles = lib.MeshGetIndices(self._cmesh)
		local indices = totable(ctriangles.array, ctriangles.n * 3)
		mesh:setVertexMap(indices)
	else
		self:getMesh()
	end
end

function PositionMesh:getMesh()
	if self._mesh ~= nil then
		return self._mesh
	end

	local usage = "static"
	if self._usage["points"] == "dynamic" then
		usage = "dynamic"
	end

	local attributes = {{"VertexPosition", "float", 2}, {"VertexTexCoord", "float", 2}}
	cvertices = lib.MeshGetVertices(self._cmesh)

	local mesh = love.graphics.newMesh(attributes, cvertices.n, "triangles", usage)
	self._mesh = mesh
	self:updateTriangles()
	self:updateVertices()
	return mesh
end


local ColorMesh = {}
ColorMesh.__index = ColorMesh

tove.newColorMesh = function(usage, tess)
	local cmesh = ffi.gc(lib.NewColorMesh(), lib.ReleaseMesh)
	tess(cmesh, -1)
	return setmetatable({_cmesh = cmesh, _mesh = nil,
		_tess = tess, _usage = usage or {}}, ColorMesh)
end

function ColorMesh:getVertexMap()
	return self._mesh:getVertexMap()
end

function ColorMesh:getUsage(what)
	return self._usage[what]
end

function ColorMesh:retesselate(flags)
	local updated = self._tess(self._cmesh, flags)
	self:updateVertices()
	if bit.band(updated, lib.UPDATE_MESH_TRIANGLES) ~= 0 then
		self:updateTriangles()
	end
end

function ColorMesh:updateVertices()
	cvertices = lib.MeshGetVertices(self._cmesh)
	ccolors = lib.MeshGetColors(self._cmesh)

	local positions = cvertices.array
	local colors = ccolors.array

	local vertices = {}
	local pi = 0
	local ci = 0
	for i = 1, cvertices.n do
		vertices[i] = {
			positions[pi + 0], positions[pi + 1],
			colors[ci + 0] / 255, colors[ci + 1] / 255,
			colors[ci + 2] / 255, colors[ci + 3] / 255}
		pi = pi + 2
		ci = ci + 4
	end

	local mesh = self._mesh
	if mesh ~= nil then
		mesh:setVertices(vertices)
	end
end

function ColorMesh:updateTriangles()
	local mesh = self._mesh
	if mesh ~= nil then
		ctriangles = lib.MeshGetIndices(self._cmesh)
		local indices = totable(ctriangles.array, ctriangles.n * 3)
		mesh:setVertexMap(indices)
	else
		self:getMesh()
	end
end

function ColorMesh:getMesh()
	if self._mesh ~= nil then
		return self._mesh
	end
	local attributes = {{"VertexPosition", "float", 2},
		{"VertexColor", "byte", 4}}

	local usage = "static"
	if self._usage["points"] == "dynamic" or self._usage["colors"] == "dynamic" then
		usage = "dynamic"
	end

	cvertices = lib.MeshGetVertices(self._cmesh)
	local mesh = love.graphics.newMesh(
		attributes, cvertices.n, "triangles", usage)
	self._mesh = mesh
	self:updateTriangles()
	self:updateVertices()
	return mesh
end
end)()
local _shaders = (function()

local love_graphics = love.graphics

local shaders = {
	line = [[
#if LINE_STYLE == 1
uniform vec4 linecolor;
#elif LINE_STYLE >= 2
uniform sampler2D linecolors;
uniform mat3 linematrix;
uniform vec2 linecscale;
#endif

#if LINE_STYLE > 0
vec4 computeLineColor(vec2 pos) {
#if LINE_STYLE == 1
	return linecolor;
#elif LINE_STYLE == 2
	float y = (linematrix * vec3(pos, 1)).y;
	y = linecscale.x + linecscale.y * y;
	return texture2D(linecolors, vec2(0.5, y));
#elif LINE_STYLE == 3
	float y = length((linematrix * vec3(pos, 1)).xy);
	y = linecscale.x + linecscale.y * y;
	return texture2D(linecolors, vec2(0.5, y));
#endif
}
#endif
]],
	lineGlue = [[
vec4 effect(vec4 c, Image t, vec2 tc, vec2 sc) {
	return computeLineColor(tc);
}
]],
			fill = [[
#if FILL_STYLE == 1
uniform vec4 fillcolor;
#elif FILL_STYLE >= 2
uniform sampler2D fillcolors;
uniform mat3 fillmatrix;
uniform vec2 fillcscale;
#endif

#if FILL_STYLE > 0
vec4 computeFillColor(vec2 pos) {
#if FILL_STYLE == 1
	return fillcolor;
#elif FILL_STYLE == 2
	float y = (fillmatrix * vec3(pos, 1)).y;
	y = fillcscale.x + fillcscale.y * y;
	return texture2D(fillcolors, vec2(0.5, y));
#elif FILL_STYLE == 3
	float y = length((fillmatrix * vec3(pos, 1)).xy);
	y = fillcscale.x + fillcscale.y * y;
	return texture2D(fillcolors, vec2(0.5, y));
#endif
}
#endif
]],
	fillGlue = [[
vec4 effect(vec4 c, Image t, vec2 tc, vec2 sc) {
	return computeFillColor(tc);
}
]]
}

shaders.code = [[
// *****************************************************************
// TÖVE - Animated vector graphics for LÖVE.
// https://github.com/poke1024/tove2d
//
// Copyright (c) 2018, Bernhard Liebl
//
// Distributed under the MIT license. See LICENSE file for details.
//
// All rights reserved.
// *****************************************************************
//
// shader implementation for tove2d vector graphics rendering.
// supports cubic bezier curves and fill rules.
// stroke rendering is supported but inefficient.
//
// Credits:
//
// the basis of the cubic root calculation was worked out by:
// https://www.particleincell.com/2013/cubic-line-intersection/
//
// segmentPointDistanceSquared() is adapted from:
// https://stackoverflow.com/questions/849211/shortest-distance-between-a-point-and-a-line-segment

#define CURVE_DATA_SIZE 4
#define T_EPS 0.0
#define SENTINEL_END 1.0
#define SENTINEL_STROKES (254.0 / 255.0)
#define MAX_LINE_ITERATIONS 14

#define LUT_LOG_N tablesize.z
#define C_ID_SCALE (255.0 / NUM_CURVES)

#define M_PI 3.1415926535897932384626433832795

uniform ivec3 tablesize;
uniform float lut[2 * LUT_SIZE];

uniform sampler2D lists;
uniform sampler2D curves;

#if LINE_STYLE > 0
uniform float linewidth; // half the linewidth
#endif

#if LINE_STYLE > 0
vec2 eval(vec4 bx, vec4 by, float t) {
	float t2 = t * t;
	vec4 c = vec4(t2 * t, t2, t, 1);
	return vec2(dot(c, bx), dot(c, by));
}

vec2 eval0(vec4 bx, vec4 by) {
	return vec2(bx.w, by.w);
}

vec2 eval1(vec4 bx, vec4 by) {
	return vec2(dot(vec4(1), bx), dot(vec4(1), by));
}

float distanceSquared(vec2 a, vec2 b) {
	vec2 c = a - b;
	return dot(c, c);
}

float segmentPointDistanceSquared(vec2 v, vec2 w, vec2 p) {
	// Return minimum distance between line segment vw and point p
	float l2 = distanceSquared(v, w);  // i.e. |w-v|^2 -  avoid a sqrt
	// Consider the line extending the segment, parameterized as v + t (w - v).
	// We find projection of point p onto the line.
	// It falls where t = [(p-v) . (w-v)] / |w-v|^2
	// We clamp t from [0,1] to handle points outside the segment vw.
	float t = clamp(dot(p - v, w - v) / l2, 0.0f, 1.0f);
	vec2 projection = v + t * (w - v);  // Projection falls on the segment
	return distanceSquared(p, mix(v, projection, step(1e-2, l2)));
}

vec2 curveTangent(vec4 bx, vec4 by, float t) {
	vec3 d_t = vec3(1, 2 * t, 3 * t * t);
	return vec2(dot(bx.zyx, d_t), dot(by.zyx, d_t));
}

float curveLineDistanceSquared(vec2 pos, vec4 bx, vec4 by, vec2 tr, float tolerance) {
	float s = 0.5 * (tr.y - tr.x);
	float t = tr.x + s;
	s *= 0.5;

	vec2 curvePoint = eval(bx, by, t);
	vec4 state = vec4(t, distanceSquared(curvePoint, pos), s, -s);

	for (int i = 0; i < MAX_LINE_ITERATIONS && state.y > tolerance; i++) {
		float tn = state.x + state.z;
		curvePoint = eval(bx, by, tn);
		float d1 = distanceSquared(curvePoint, pos);
		float s1 = state.z * 0.5;
		state = d1 < state.y ?
			vec4(tn, d1, s1, -s1) :
			vec4(state.xyw, s1 * 0.5);
	}

	vec2 w = normalize(curveTangent(bx, by, state.x)) * linewidth;
	return segmentPointDistanceSquared(curvePoint - w, curvePoint + w, pos);
}

bool onCurveLine(vec2 pos, vec4 bx, vec4 by, vec4 roots, float tolerance) {
	float t0 = 0.0;
	do {
		float t1 = roots.x;
		if (curveLineDistanceSquared(
			pos, bx, by, vec2(t0, t1), tolerance) <= tolerance) {
			return true;
		}
		roots = vec4(roots.yzw, 1.0);
		t0 = t1;
	} while (t0 < 1.0);

	return false;
}
#endif

vec3 goodT(vec3 t) {
	return step(vec3(0.0 - T_EPS), t) - step(vec3(1.0 + T_EPS), t);
}

#if FILL_RULE == 0
float clockwise(vec4 by, float t, float t2) {
	vec3 d_t = vec3(1, 2 * t, 3 * t2);
	return sign(dot(by.zyx, d_t));
}

int contribute(vec4 bx, vec4 by, float t, float x) {
	float t2 = t * t;
	bool ok = clamp(t, 0.0 - T_EPS, 1.0 + T_EPS) == t &&
		dot(bx, vec4(t * t2, t2, t, 1)) > x;
	return int(clockwise(by, t, t2)) * int(ok);
}

int contribute3(vec4 bx, vec4 by, vec3 t, float x) {
	vec3 t2 = t * t;
	vec3 hit = goodT(t) * step(
		vec3(x), bx.x * t * t2 + bx.y * t2 + bx.z * t + bx.w);
	vec3 cw = vec3(clockwise(by, t.x, t2.x),
		clockwise(by, t.y, t2.y),
		clockwise(by, t.z, t2.z));
	return int(dot(vec3(1), cw * hit));
}

#elif FILL_RULE == 1
int contribute(vec4 bx, vec4 by, float t, float x) {
	float t2 = t * t;
	return int(clamp(t, 0.0 - T_EPS, 1.0 + T_EPS) == t &&
		dot(bx, vec4(t * t2, t2, t, 1)) > x);
}

int contribute3(vec4 bx, vec4 by, vec3 t, float x) {
	vec3 t2 = t * t;
	vec3 hit = goodT(t) * step(
		vec3(x), bx.x * t * t2 + bx.y * t2 + bx.z * t + bx.w);
	return int(dot(hit, vec3(1)));
}
#endif

#if LINE_STYLE > 0
bool checkLine(float curveId, vec2 position, vec2 axis1) {
	vec4 bounds = texture2D(curves, vec2(2.0 / CURVE_DATA_SIZE, curveId));
	vec2 off = clamp(position, bounds.xy, bounds.zw) - position;
	if (abs(dot(off, axis1)) < linewidth) {
		vec4 bx = texture2D(curves, vec2(0.0 / CURVE_DATA_SIZE, curveId));
		vec4 by = texture2D(curves, vec2(1.0 / CURVE_DATA_SIZE, curveId));
		vec4 roots = texture2D(curves, vec2(3.0 / CURVE_DATA_SIZE, curveId));
		return onCurveLine(position, bx, by, roots, linewidth * linewidth);
	} else {
		return false;
	}
}
#endif

int advancedMagic(vec4 bx, vec4 by, vec4 P, float position, float upperBound) {
#if FILL_STYLE > 0
	if (position > upperBound) {
		return 0;
	}

	vec3 ABC = P.yzw / P.xxx;
	// note: ABC.x might be nan due to P.y == 0.

	if (abs(P.x) < 1e-2 || abs(ABC.x) > 1000.0) {
		// not cubic in y; or cubic, but so large, that our numeric
		// calculations would go havoc due to cubic powers on A.
		if (abs(P.y) < 1e-2) {
			// linear.
			float a = P.z;
			float b = P.w;

			return contribute(bx, by, -b / a, position);
		} else {
			// 	quadratic.
			float a = P.y;
			float b = P.z;
			float c = P.w;

			float D = sqrt(b * b - 4 * a * c);
			float n = 2 * a;
			int z = contribute(bx, by, (-b + D) / n, position);
			if (D > 0.0) {
				z += contribute(bx, by, (-b - D) / n, position);
			}
			return z;
		}
	} else {
		// cubic.
		float A = ABC.x;
		float B = ABC.y;
		float C = ABC.z;

		float A2 = A * A;
		float Q = (3.0 * B - A2) / 9.0;
		float R = (9.0 * A * B - 27.0 * C - 2 * A2 * A) / 54.0;

		float A_third = A / 3.0;
		float Q3 = Q * Q * Q;
		float D = Q3 + R * R;

		if (D > 0.0) { // we have complex or duplicate roots
			float sqrtD = sqrt(D);
			vec2 r = vec2(R + sqrtD, R - sqrtD);
			vec2 ST = sign(r) * pow(r, vec2(1.0 / 3.0));
			float st = ST.x + ST.y;

			if (abs(ST.x - ST.y) < 1e-2) { // complex roots?
				// real root:
				int z = contribute(bx, by, -A_third + st, position);
				// real part of complex root:
				z += contribute(bx, by, -A_third - st / 2, position) * 2;
				return z;
			} else {
				// real root:
				return contribute(bx, by, -A_third + st, position);
			}
		} else {
			vec2 tmp = sqrt(vec2(-Q3, -Q));
			vec3 phi = vec3(acos(R / tmp.x)) + vec3(0, 2 * M_PI, 4 * M_PI);
			vec3 t = 2 * tmp.y * cos(phi / 3.0) - A_third;
			return contribute3(bx, by, t, position);
		}
	}
#else
	return 0;
#endif
}

bool isInside(int z) {
#if FILL_RULE == 0
	return z != 0;
#elif FILL_RULE == 1
	return mod(z, 2) > 0.5;
#endif
}

#define X_LO lohi.x
#define X_HI lohi.y
#define X_LOHI lohi.xy
#define Y_LO lohi.z
#define Y_HI lohi.w
#define Y_LOHI lohi.zw
#define XY_LO lohi.xz
#define XY_HI lohi.yw

#define X_MID mid.x
#define Y_MID mid.y

ivec4 bsearch(ivec4 lohi, vec2 position) {
    ivec2 mid = (XY_LO + XY_HI) / 2;
	ivec2 lutIndex = mid * 2;

    bvec2 notDone = lessThan(XY_LO, XY_HI);
    bvec2 smaller = lessThan(
		vec2(lut[lutIndex.x], lut[lutIndex.y + 1]), position);

	ivec4 nextLo = ivec4(mid + vec2(1), XY_HI);
    return ivec4(
		notDone.x ? (smaller.x ? nextLo.xz : vec2(X_LO, X_MID)) : X_LOHI,
        notDone.y ? (smaller.y ? nextLo.yw : vec2(Y_LO, Y_MID)) : Y_LOHI);
}

ivec2 search(vec2 position) {
	ivec4 lohi = ivec4(0, tablesize.x, 0, tablesize.y);
	for (int i = 0; i < LUT_LOG_N; i++) {
		lohi = bsearch(lohi, position);

	}
	return ivec2(min(lohi.xz, tablesize.xy - ivec2(1)));
}

vec2 orient(ivec2 at, vec2 position, out bool rayOnX) {
	ivec2 index = 2 * (at - ivec2(1));

	float x0 = lut[index.x + 0];
	float x1 = lut[index.x + 2];
	float y0 = lut[index.y + 1];
	float y1 = lut[index.y + 3];

	vec2 d0 = position - vec2(x0, y0);
	vec2 d1 = vec2(x1, y1) - position;

	float dx = min(d0.x, d1.x);
	float dy = min(d0.y, d1.y);
	rayOnX = dx < dy;

	// reduce remaining numerical inaccuracies.
	vec2 p0 = vec2(x0, y0);
	vec2 p1 = vec2(x1, y1);
	vec2 center = (p0 + p1) / 2;
	vec2 margin = vec2(0.5);
	vec2 npos = mix(min(p0 + margin, center), position, step(margin, d0));
	npos = mix(max(center, p1 - margin), npos, step(margin, d1));
	return rayOnX ? vec2(position.x, npos.y) : vec2(npos.x, position.y);
}

vec4 effect(vec4 _1, Image _2, vec2 position, vec2 _3) {
	ivec2 at = search(position);

	bool rayOnX;
	position = orient(at, position, rayOnX);

	vec2 axis1 = vec2(int(rayOnX), 1 - int(rayOnX));
	vec2 axis2 = vec2(1) - axis1;

	float rayPos = dot(position, axis1);
	vec4 C = vec4(0.0, 0.0, 0.0, dot(position, axis2));

	int z = 0;

	vec2 blockpos = rayOnX ?
		vec2(0, (at.y - 1 + LISTS_H / 2) / float(LISTS_H)) :
		vec2(0, (at.x - 1) / float(LISTS_H));
	vec4 curveIds = texture2D(lists, blockpos) * C_ID_SCALE;
	int k = 0;

	while (curveIds.x < SENTINEL_STROKES * C_ID_SCALE) {
		float curveId = curveIds.x;
		vec4 bx = texture2D(curves, vec2(0.0 / CURVE_DATA_SIZE, curveId));
		vec4 by = texture2D(curves, vec2(1.0 / CURVE_DATA_SIZE, curveId));
		vec4 bounds = texture2D(curves, vec2(2.0 / CURVE_DATA_SIZE, curveId));

#if LINE_STYLE > 0
		vec2 off = clamp(position, bounds.xy, bounds.zw) - position;

		if (abs(dot(off, axis1)) < linewidth) {
			vec4 roots = texture2D(curves, vec2(3.0 / CURVE_DATA_SIZE, curveId));
			if (onCurveLine(position, bx, by, roots, linewidth * linewidth)) {
				return computeLineColor(position);
			}
		}

		if (dot(off, axis2) == 0.0) {
#endif

			z += advancedMagic(
				rayOnX ? bx : by,
				rayOnX ? by : bx,
				rayOnX ? -by + C : bx - C,
				rayPos,
				dot(bounds.zw, axis1));

#if LINE_STYLE > 0
		}
#endif

		if (++k < 4) {
			curveIds.xyzw = curveIds.yzwx;
		} else {
			blockpos += vec2(1.0 / LISTS_W, 0);
			if (blockpos.x >= 1.0) {
				// something went horribly wrong.
				return vec4(0.33, 1, 1, 1);
			}
			curveIds = texture2D(lists, blockpos) * C_ID_SCALE;
			k = 0;
		}
	}

#if LINE_STYLE > 0
	if (curveIds.x == SENTINEL_STROKES * C_ID_SCALE) {
		if (++k < 4) {
			curveIds.xyzw = curveIds.yzwx;
		} else {
			blockpos += vec2(1.0 / LISTS_W, 0);
			curveIds = texture2D(lists, blockpos) * C_ID_SCALE;
			k = 0;
		}
		while (curveIds.x < SENTINEL_END * C_ID_SCALE) {
			if (checkLine(curveIds.x, position, axis1)) {
				return computeLineColor(position);
			}

			if (++k < 4) {
				curveIds.xyzw = curveIds.yzwx;
			} else {
				blockpos += vec2(1.0 / LISTS_W, 0);
				if (blockpos.x >= 1.0) {
					// something went horribly wrong.
					return vec4(0.33, 1, 1, 1);
				}
				curveIds = texture2D(lists, blockpos) * C_ID_SCALE;
				k = 0;
			}
		}
	}
#endif

#if FILL_STYLE > 0
	if (isInside(z)) {
		return computeFillColor(position);
	} else {
		discard;
	}
#else
	discard;
#endif
}
]]

local max = math.max
local floor = math.floor

local _log2 = math.log(2)
local function log2(n)
	return math.log(n) / _log2
end

local function next2(n)
	return math.pow(2, math.ceil(log2(max(8, n))))
end

local function newShader(data)
	local geometry = data.geometry
	local lutN = geometry.lookupTableSize
	local f = string.format
	local code = {
		f("#define LUT_SIZE %d", lutN),
		f("#define NUM_CURVES %d", geometry.numCurves),
		f("#define LISTS_W %d", geometry.listsTextureSize[0]),
		f("#define LISTS_H %d", geometry.listsTextureSize[1]),
		f("#define LINE_STYLE %d", data.color.line.style),
		f("#define FILL_STYLE %d", data.color.fill.style),
		f("#define FILL_RULE %d", geometry.fillRule),
		shaders.line,
		shaders.fill,
		shaders.code
	}
	return love_graphics.newShader(table.concat(code, "\n"))
end

local function newLineShader(data)
	if data.style < 1 then
		return nil
	end
	local code = {
		string.format("#define LINE_STYLE %d", data.style),
		shaders.line,
		shaders.lineGlue
	}
	return love_graphics.newShader(table.concat(code, "\n"))
end

local function newFillShader(data)
	if data.style < 1 then
		return nil
	end
	local code = {
		string.format("#define FILL_STYLE %d", data.style),
		shaders.fill,
		shaders.fillGlue
	}
	return love_graphics.newShader(table.concat(code, "\n"))
end

local function sendLUT(shader, data)
	local f = data.lookupTableFill
	local fx = f[0]
	local fy = f[1]

	local fill = max(fx, fy)

	shader:send("lut", unpack(totable(data.lookupTable, 2 * fill)))
	shader:send("tablesize", {fx, fy, floor(log2(fill)) + 1})
end

local feed = (function()

local function getMeshBounds(data)
	local x1 = data.bounds[0]
	local y1 = data.bounds[1]
	local x2 = data.bounds[2]
	local y2 = data.bounds[3]
	return x1, y1, x2, y2
end


local function newGradientData(gradient)
	local n = gradient.numColors

	local data = ffi.new("ToveShaderGradientData")
	gradient.data = data

	local imageData = love.image.newImageData(1, n, "rgba8")
	data.colorsTexture = imageData:getPointer()
	data.colorsTextureRowBytes = imageData:getSize() / n

	return {data = data, imageData = imageData, texture = nil}
end

local function newGradientTexture(d)
	d.texture = love_graphics.newImage(d.imageData)
	d.texture:setFilter("nearest", "linear")
	d.texture:setWrap("clamp", "clamp")
end

local function reloadGradientTexture(d)
	d.texture:replacePixels(d.imageData)
end

local function sendColor(shader, uniform, rgba)
	shader:send(uniform, {rgba.r, rgba.g, rgba.b, rgba.a})
end

local function sendGradientMatrix(shader, uniform, gradient)
	shader:send(uniform, totable(gradient.data.matrix, 9))
end


local NullColorFeed = {}
NullColorFeed.__index = NullColorFeed

function NullColorFeed:beginInit()
end
function NullColorFeed:endInit(path)
end
function NullColorFeed:update(chg1, path)
end


local ColorFeed = {}
ColorFeed.__index = ColorFeed

local _flags = {
	fill = lib.CHANGED_FILL_STYLE,
	line = lib.CHANGED_LINE_STYLE
}

local _uniforms = {
	fill = {},
	line = {}
}

for _, name in ipairs({"color", "colors", "matrix", "cscale"}) do
	_uniforms.fill[name] = "fill" .. name
	_uniforms.line[name] = "line" .. name
end

local function newColorFeed(shader, type, colorData)
	if shader == nil then
		return setmetatable({}, NullColorFeed)
	end
	return setmetatable({shader = shader, colorData = colorData,
		uniforms = _uniforms[type], flag = _flags[type]}, ColorFeed)
end

function ColorFeed:beginInit()
	local colorData = self.colorData
	if colorData.style >= 2 then
		self.gradientData = newGradientData(colorData.gradient)
	end
end

function ColorFeed:endInit(path)
	local gradientData = self.gradientData

	if gradientData ~= nil then
		newGradientTexture(gradientData)
	end

	local colorData = self.colorData
	local shader = self.shader
	local uniforms = self.uniforms

	if colorData.style == 1 then
		sendColor(shader, uniforms.color, colorData.rgba)
	elseif colorData.style >= 2 then
		shader:send(uniforms.colors, gradientData.texture)
		local gradient = colorData.gradient
		sendGradientMatrix(shader, uniforms.matrix, gradient)
		local s = 0.5 / gradient.numColors
		shader:send(uniforms.cscale, {s, 1 - 2 * s})
	end
end

function ColorFeed:update(chg1, path)
	if bit.band(chg1, self.flag) ~= 0 then
		local shader = self.shader
		local uniforms = self.uniforms
		local colorData = self.colorData
		if colorData.style == 1 then
			sendColor(shader, uniforms.color, colorData.rgba)
		elseif colorData.style >= 2 then
			reloadGradientTexture(self.gradientData)
			local gradient = colorData.gradient
			sendGradientMatrix(shader, uniforms.matrix, gradient)
			local s = 0.5 / gradient.numColors
			shader:send(uniforms.cscale, {s, 1 - 2 * s})
		end
	end
end


local GeometryFeed = {}
GeometryFeed.__index = GeometryFeed

local function newGeometryFeed(shader, data)
	return setmetatable({shader = shader, data = data}, GeometryFeed)
end

function GeometryFeed:beginInit()
	local data = self.data


	local listsImageData = love.image.newImageData(
		data.listsTextureSize[0], data.listsTextureSize[1],
		ffi.string(data.listsTextureFormat))
	data.listsTextureRowBytes = listsImageData:getSize() / data.listsTextureSize[1]

	local curvesImageData = love.image.newImageData(
		data.curvesTextureSize[0], data.curvesTextureSize[1],
		ffi.string(data.curvesTextureFormat))
	data.curvesTextureRowBytes = curvesImageData:getSize() / data.curvesTextureSize[1]

	--print("data.curvesTextureRowBytes", data.curvesTextureRowBytes)

	data.listsTexture = listsImageData:getPointer()
	data.curvesTexture = curvesImageData:getPointer()

	self.listsImageData = listsImageData
	self.curvesImageData = curvesImageData
end

function GeometryFeed:endInit(lineStyle)
	local listsTexture = love.graphics.newImage(self.listsImageData)
	local curvesTexture = love.graphics.newImage(self.curvesImageData)
	listsTexture:setFilter("nearest", "nearest")
	curvesTexture:setFilter("nearest", "nearest")
	self.listsTexture = listsTexture
	self.curvesTexture = curvesTexture


	local shader = self.shader
	local data = self.data


	local x1, y1, x2, y2 = getMeshBounds(data)
	local vertices = {{x1, y1, x1, y1}, {x2, y1, x2, y1},
		{x2, y2, x2, y2}, {x1, y2, x1, y2}}
	self.mesh = love.graphics.newMesh(
		{{"VertexPosition", "float", 2}, {"VertexTexCoord", "float", 2}}, vertices)

	sendLUT(shader, data)

	shader:send("lists", listsTexture)
	shader:send("curves", curvesTexture)

	if lineStyle >= 1 then
		shader:send("linewidth", data.strokeWidth / 2)
	end
end

function GeometryFeed:update(chg2)
	local data = self.data

	if bit.band(chg2, lib.CHANGED_POINTS) ~= 0 and data.lookupTableFill[1] > 1 then
		local shader = self.shader
		sendLUT(shader, data)

		self.listsTexture:replacePixels(self.listsImageData)
		self.curvesTexture:replacePixels(self.curvesImageData)

		local x1, y1, x2, y2 = getMeshBounds(data)
		self.mesh:setVertices({{x1, y1, x1, y1}, {x2, y1, x2, y1}, {x2, y2, x2, y2}, {x1, y2, x1, y2}})
	end
end

return {
	newColorFeed = newColorFeed,
	newGeometryFeed = newGeometryFeed
}
end)()

local MeshShader = {}
MeshShader.__index = MeshShader

local function newMeshShaderLinkData(path, tess, usage)
	local fillMesh = tove.newPositionMesh(usage)
	local lineMesh = tove.newPositionMesh(usage)

	tess(path, fillMesh._cmesh, lineMesh._cmesh, lib.UPDATE_MESH_EVERYTHING)

	local link = ffi.gc(lib.NewShaderLink(0), lib.ReleaseShaderLink)
	local data = lib.ShaderLinkGetColorData(link)
	lib.ShaderLinkBeginUpdate(link, path, true)

	--print("xx", data.line.style, data.fill.style)

	local lineShader = newLineShader(data.line)
	local fillShader = newFillShader(data.fill)

	local lineColorFeed = feed.newColorFeed(lineShader, "line", data.line)
	lineColorFeed:beginInit()
	local fillColorFeed = feed.newColorFeed(fillShader, "fill", data.fill)
	fillColorFeed:beginInit()

	lib.ShaderLinkEndUpdate(link, path, true)
	lineColorFeed:endInit(path)
	fillColorFeed:endInit(path)

	path:clearChanges()

	return {
		link = link,
		data = data,
		lineShader = lineShader,
		fillShader = fillShader,
		lineColorFeed = lineColorFeed,
		fillColorFeed = fillColorFeed,
		lineMesh = lineMesh,
		fillMesh = fillMesh
	}
end

local newMeshShader = function(path, tess, usage)
	return setmetatable({path = path, tess = tess, usage = usage,
		linkdata = newMeshShaderLinkData(path, tess, usage)}, MeshShader)
end

function MeshShader:update()
	local linkdata = self.linkdata
	local path = self.path

	local flags = path:fetchChanges(lib.CHANGED_POINTS)

	if bit.band(flags, lib.CHANGED_POINTS) ~= 0 then
		if self.usage["points"] ~= "dynamic" then
			tove.warn(path, "static mesh points changed.")
			self.linkdata = newMeshShaderLinkData(self.path, self.tess, self.usage)
			return
		end

		local tessFlags = lib.UPDATE_MESH_VERTICES

		if self.usage["triangles"] == "dynamic" then
			tessFlags = bit.bor(tessFlags, lib.UPDATE_MESH_AUTO_TRIANGLES)
		end

		local updated = self.tess(self.path, linkdata.fillMesh._cmesh,
			linkdata.lineMesh._cmesh, tessFlags)

		if bit.band(updated, lib.UPDATE_MESH_TRIANGLES) ~= 0 then
			linkdata.fillMesh:updateTriangles()
		end

		if linkdata.fillShader ~= nil then
			linkdata.fillMesh:updateVertices()
		end
		if linkdata.lineShader ~= nil then
			linkdata.lineMesh:updateVertices()
		end
	end

	local link = linkdata.link
	local chg1 = lib.ShaderLinkBeginUpdate(link, path, false)

	if bit.band(chg1, lib.CHANGED_RECREATE) ~= 0 then
		tove.warn(path, "mesh recreation triggered.")
		self.linkdata = newMeshShaderLinkData(self.path, self.tess, self.usage)
		return
	end

	linkdata.lineColorFeed:update(chg1, path)
	linkdata.fillColorFeed:update(chg1, path)

	local chg2 = lib.ShaderLinkEndUpdate(link, path, false)
end

function MeshShader:draw()
	self:update()
	local linkdata = self.linkdata
	if linkdata.fillShader ~= nil then
		love_graphics.setShader(linkdata.fillShader)
		local mesh = linkdata.fillMesh:getMesh()
		if mesh ~= nil then
			love_graphics.draw(mesh)
		end
	end
	if linkdata.lineShader ~= nil then
		love_graphics.setShader(linkdata.lineShader)
		local mesh = linkdata.lineMesh:getMesh()
		if mesh ~= nil then
			love_graphics.draw(mesh)
		end
	end
end


local PathShader = {}
PathShader.__index = PathShader

local function newPathShaderLinkData(path)
	local link = ffi.gc(lib.NewShaderLink(path:getNumCurves()), lib.ReleaseShaderLink)
	local data = lib.ShaderLinkGetData(link)

	lib.ShaderLinkBeginUpdate(link, path, true)
	local shader = newShader(data)

	local lineColorFeed = feed.newColorFeed(shader, "line", data.color.line)
	lineColorFeed:beginInit()
	local fillColorFeed = feed.newColorFeed(shader, "fill", data.color.fill)
	fillColorFeed:beginInit()

	local geometryFeed = feed.newGeometryFeed(shader, data.geometry)
	geometryFeed:beginInit()

	lib.ShaderLinkEndUpdate(link, path, true)

	lineColorFeed:endInit(path)
	fillColorFeed:endInit(path)
	geometryFeed:endInit(data.color.line.style)

	path:clearChanges()

	return {
		link = link,
		shader = shader,
		geometryFeed = geometryFeed,
		lineColorFeed = lineColorFeed,
		fillColorFeed = fillColorFeed
	}
end

local newPathShader = function(path)
	return setmetatable({
		path = path,
		linkdata = newPathShaderLinkData(path)
	}, PathShader)
end

function PathShader:update()
	local path = self.path
	local linkdata = self.linkdata
	local link = linkdata.link

	local chg1 = lib.ShaderLinkBeginUpdate(link, path, false)

	if bit.band(chg1, lib.CHANGED_RECREATE) ~= 0 then
		self.linkdata = newPathShaderLinkData(path)
		return
	end

	linkdata.lineColorFeed:update(chg1, path)
	linkdata.fillColorFeed:update(chg1, path)

	local chg2 = lib.ShaderLinkEndUpdate(link, path, false)

	linkdata.geometryFeed:update(chg2)
end

function PathShader:draw()
	self:update()
	local linkdata = self.linkdata
	love_graphics.setShader(linkdata.shader)
	love_graphics.draw(linkdata.geometryFeed.mesh)
end

return {
	newMeshShader = newMeshShader,
	newPathShader = newPathShader
}
end)()
local Graphics = (function()

local cquality = (function()

local fixed = {}
tove.fixed = function(depth)
	return setmetatable({depth = depth}, fixed)
end

local adaptive = {}
tove.adaptive = function(quality)
	return setmetatable(quality, adaptive)
end

local function setAdaptiveQuality(record, quality)
	record.recursionLimit = 8
	local adaptive = record.adaptive
	adaptive.valid = true


	if quality < 0.1 then -- special low quality tier
		adaptive.distanceTolerance = 100.0
		adaptive.colinearityEpsilon = 1.0 / quality
		adaptive.angleTolerance = (math.pi / 16) * (0.5 / quality)
	else
		adaptive.distanceTolerance = 100.0 / (1 + quality)
		adaptive.colinearityEpsilon = 0.1 / (1 + 10 * quality)
		adaptive.angleTolerance = math.pi / (8 + math.min(1, quality) * 8)
	end
	adaptive.angleEpsilon = 0.0
	adaptive.cuspLimit = 0.0
end

return function (quality, usage)
	local t = type(quality)
	if t == "number" then
		local record = ffi.new("ToveTesselationQuality")
		if usage["points"] == "dynamic" then
			record.adaptive.valid = false
			record.recursionLimit = math.floor(quality * 4)
		else
			setAdaptiveQuality(record, quality)
		end
		quality = record
	elseif t == "nil" then
		local record = ffi.new("ToveTesselationQuality")
		if usage["points"] == "dynamic" then
			record.adaptive.valid = false
			record.recursionLimit = 5
		else
			setAdaptiveQuality(record, 1)
		end
		quality = record
	elseif t == "table" and getmetatable(quality) == fixed then
		local record = ffi.new("ToveTesselationQuality")
		record.adaptive.valid = false
		record.recursionLimit = quality.depth
		quality = record
	elseif t == "table" and getmetatable(quality) == adaptive then
		local record = ffi.new("ToveTesselationQuality")
		record.recursionLimit = quality.recursionLimit or 8
		local adaptive = record.adaptive
		adaptive.valid = true
		adaptive.distanceTolerance = quality.distanceTolerance or 100.0
		adaptive.colinearityEpsilon = quality.colinearityEpsilon or 1.0
		adaptive.angleTolerance = quality.angleTolerance or (math.pi / 16)
		adaptive.angleEpsilon = quality.angleEpsilon or 0.0
		adaptive.cuspLimit = quality.cuspLimit or 0.0
		quality = record
	end
	return quality
end
end)()

local Paths = {}
Paths.__index = function (self, i)
	return ffi.gc(lib.GraphicsGetPath(self._ref, i), lib.ReleasePath)
end

local Graphics = {}
Graphics.__index = function (graphics, key)
	if key == "npaths" then
		return lib.GraphicsGetNumPaths(graphics._ref)
	else
		return Graphics[key]
	end
end

local function bind(methodName, libFuncName)
	Graphics[methodName] = function(self, ...)
		lib[libFuncName](self._ref, ...)
		return self
	end
end

tove.newGraphics = function(svg, size)
	local ref = ffi.gc(lib.NewGraphics(svg, "px", 72), lib.ReleaseGraphics)
	local graphics = setmetatable({
		_ref = ref,
		_cache = nil,
		_display = {mode = "bitmap"},
		_resolution = 1,
		_usage = {},
		paths = setmetatable({_ref = ref}, Paths)}, Graphics)
	if type(size) == "number" then
		graphics:rescale(size)
	elseif size == nil then -- auto
		local x0, y0, x1, y1 = graphics:computeAABB()
		graphics:rescale(math.min(1024, math.max(x1 - x0, y1 - y0)))
	end
	return graphics
end

bind("clone", "CloneGraphics")

function Graphics:clearCache()
	self._cache = nil
end

function Graphics:beginPath()
	return ffi.gc(lib.GraphicsBeginTrajectory(self._ref), lib.ReleaseTrajectory)
end
bind("closePath", "GraphicsCloseTrajectory")

function Graphics:getCurrentPath()
	return ffi.gc(lib.GraphicsGetCurrentPath(self._ref), lib.ReleasePath)
end

bind("addPath", "GraphicsAddPath")

function Graphics:fetchChanges(flags)
	return lib.GraphicsFetchChanges(self._ref, flags)
end

function Graphics:moveTo(x, y)
	local t = self:beginPath()
	return newCommand(t, lib.TrajectoryMoveTo(t, x, y))
end

function Graphics:lineTo(x, y)
	local t = self:beginPath()
	return newCommand(t, lib.TrajectoryLineTo(t, x, y))
end

function Graphics:curveTo(...)
	local t = self:beginPath()
	return newCommand(t, lib.TrajectoryCurveTo(t, ...))
end

function Graphics:arc(x, y, r, a1, a2, ccw)
	lib.TrajectoryArc(self:beginPath(), x, y, r, a1, a2, ccw or false)
end

function Graphics:drawRect(x, y, w, h, rx, ry)
	local t = self:beginPath()
	return newCommand(t, lib.TrajectoryDrawRect(t, x, y, w, h or w, rx or 0, ry or 0))
end

function Graphics:drawCircle(x, y, r)
	local t = self:beginPath()
	return newCommand(t, lib.TrajectoryDrawEllipse(t, x, y, r, r))
end

function Graphics:drawEllipse(x, y, rx, ry)
	local t = self:beginPath()
	return newCommand(t, lib.TrajectoryDrawEllipse(t, x, y, rx, ry or rx))
end

function Graphics:setFillColor(r, g, b, a)
	local color = Paint._wrap(r, g, b, a)
	lib.GraphicsSetFillColor(self._ref, color._ref)
	return color
end

function Graphics:setLineDash(...)
	local dashes = {...}
	local n = #dashes
	local data = ffi.new("float[" .. tostring(n) .. "]", dashes)
	lib.GraphicsSetLineDash(self._ref, data, n)
	return self
end

bind("setLineWidth", "GraphicsSetLineWidth")
bind("setLineDashOffset", "GraphicsSetLineDashOffset")

function Graphics:setLineColor(r, g, b, a)
	local color = Paint._wrap(r, g, b, a)
	lib.GraphicsSetLineColor(self._ref, color._ref)
	return color
end

bind("fill", "GraphicsFill")
bind("stroke", "GraphicsStroke")

function Graphics:computeAABB()
	local bounds = lib.GraphicsGetBounds(self._ref)
	return bounds.x0, bounds.y0, bounds.x1, bounds.y1
end

function Graphics:setDisplay(mode, quality)
	if mode == "flatmesh" then
		mode = "mesh"
		self._usage["gradients"] = "fast"
	end
	self._cache = nil
	self._display = {mode = mode, quality = quality, cquality = cquality(quality, self._usage)}
end

function Graphics:setResolution(resolution)
	if resolution ~= self._resolution then
		self._cache = nil
		self._resolution = resolution
	end
end

function Graphics:setUsage(what, usage)
	if usage ~= self._usage[what] then
		self._cache = nil
		self._usage[what] = usage
		if what == "points" then
			self._usage["triangles"] = usage
		end
		self._display.cquality = cquality(self._display.quality, self._usage)
	end
end

function Graphics:cache()
	self._cache = nil
	self:_create()
end

function Graphics:transform(sx, sy, tx, ty)
	if sy == nil then
		sy = sx
	end
	lib.GraphicsTransform(self._ref, sx or 1, sy or 1, tx or 0, ty or 0)
	self._cache = nil
end

function Graphics:rescale(size, center)
	local x0, y0, x1, y1 = self:computeAABB()
	local s = size / math.max(x1 - x0, y1 - y0)
	if center or true then
		self:transform(s, s, -(x0 + x1) / 2, -(y0 + y1) / 2)
	else
		self:transform(s, s)
	end
end

function Graphics:getNumTriangles()
	self:_create()
	if self._cache ~= nil and self._cache.mesh ~= nil then
		return #self._cache.mesh:getVertexMap() / 3
	else
		return 2
	end
end

function Graphics:draw(x, y, r, sx, sy)
	self:_create()
	self._cache.draw(x, y, r, sx, sy)
end

function Graphics:rasterize(width, height, tx, ty, scale, quality)
	width = math.ceil(width)
	height = math.ceil(height)
	local data = lib.GraphicsRasterize(
		self._ref, width, height, tx or 0, ty or 0, scale or 1, quality)
	if data == nil then
		error(string.format("could rasterize image %d x %d", width, height))
	end
	local loveImageData = love.image.newImageData(
		width, height, "rgba8", ffi.string(data.pixels, width * height * 4))
	lib.DeleteImage(data)
	return loveImageData
end

function Graphics:tesselate(scale, quality)
	local mesh = newColorMesh()
	lib.GraphicsTesselate(self._ref, mesh.cmesh, scale or 1, quality, -1)
	return mesh:getMesh()
end

function Graphics:animate(a, b, t)
	lib.GraphicsAnimate(self._ref, a._ref, b._ref, t or 0)
end

local orientations = {
	cw = lib.ORIENTATION_CW,
	ccw = lib.ORIENTATION_CCW
}

function Graphics:setOrientation(orientation)
	lib.GraphicsSetOrientation(self._ref, orientations[orientation])
end

function Graphics:clean(eps)
	lib.GraphicsClean(self._ref, eps or 0.0)
end

function Graphics:shaders(gen)
	local npaths = lib.GraphicsGetNumPaths(self._ref)
	local shaders = {}
	for i = 1, npaths do
		shaders[i] = gen(lib.GraphicsGetPath(self._ref, i))
	end
	return shaders
end

local create = (function()

local function createDrawMesh(mesh, x0, y0, s)
	local g = love.graphics
	return function (x, y, r, sx, sy)
		if mesh == nil then
			return
		end
		g.draw(mesh,
			(x or 0) + x0, (y or 0) + y0,
			r or 0, s * (sx or 1), s * (sy or 1))
	end
end

local function createDrawShaders(shaders, s)
	local g = love.graphics
	return function(x, y, r, sx, sy)
		g.push("transform")
		g.translate(x or 0, y or 0)
		g.rotate(r or 0)
		g.scale((sx or 1) * s, (sy or 1) * s)
		for _, s in ipairs(shaders) do
			s:draw()
		end
		g.pop()
		g.setShader()
	end
end

local function _changeBitmap(graphics)
	return graphics:fetchChanges(lib.CHANGED_ANYTHING) ~= 0
end

local function _changeFlatMesh(graphics)
	local flags = graphics:fetchChanges(lib.CHANGED_ANYTHING)
	if flags >= lib.CHANGED_GEOMETRY then
		return true
	end

	local update = 0
	if bit.band(flags, lib.CHANGED_FILL_STYLE + lib.CHANGED_LINE_STYLE) ~= 0 then
		update = bit.bor(update, lib.UPDATE_MESH_COLORS)
	end

	if bit.band(flags, lib.CHANGED_POINTS) ~= 0 then
		local mesh = graphics._cache.mesh
		if mesh:getUsage("points") == "dynamic" then
			update = bit.bor(update, lib.UPDATE_MESH_VERTICES)
		else
			tove.warn(graphics, "static mesh points changed.")
			return true
		end
	end

	if update ~= 0 then
		local mesh = graphics._cache.mesh
		mesh:retesselate(update)
	end

	return false
end

local function _changeShadedMesh(graphics)
	return graphics:fetchChanges(lib.CHANGED_GEOMETRY) ~= 0
end

local function _changeCurves(graphics)
	return graphics:fetchChanges(lib.CHANGED_GEOMETRY) ~= 0
end

local create = {}

create.bitmap = function(self)
	local resolution = self._resolution
	local x0, y0, x1, y1 = self:computeAABB()
	local imageData = self:rasterize(
		resolution * (x1 - x0),
		resolution * (y1 - y0), -x0, -y0,
		resolution)
	local mesh = love.graphics.newImage(imageData)
	return {
		mesh = mesh,
		draw = createDrawMesh(mesh, x0, y0, 1 / resolution),
		change = _changeBitmap
	}
end

create.mesh = function(self)
	local resolution = self._resolution
	local cquality = self._display.cquality
	local usage = self._usage

	if usage["gradients"] == "fast" then
		local gref = self._ref
		local mesh = tove.newColorMesh(usage, function (cmesh, flags)
			local res = lib.GraphicsTesselate(
				gref, cmesh, resolution, cquality, flags)
			tove.error(res.err)
			return res.update
		end)
		return {
			mesh = mesh,
			draw = createDrawMesh(mesh:getMesh(), 0, 0, 1 / resolution),
			change = _changeFlatMesh
		}
	else
		local tess = function(path, fill, line, flags)
			local res = lib.PathTesselate(
				path, fill, line, resolution or 1, cquality, flags)
			tove.error(res.err)
			return res.update
		end
		local shaders = self:shaders(function (path)
			return _shaders.newMeshShader(path, tess, usage)
		end)
		return {
			draw = createDrawShaders(shaders, 1 / resolution),
			change = _changeShadedMesh
		}
	end
end

create.curves = function(self)
	return {
		draw = createDrawShaders(self:shaders(_shaders.newPathShader), 1),
		change = _changeCurves
	}
end

return function(self)
	local cache = self._cache
	if cache ~= nil then
		if not cache.change(self) then
			return
		end
		self._cache = nil
		cache = nil
	end

	local mode = self._display.mode
	local f = create[mode]
	if f ~= nil then
		self._cache = f(self)
	else
		error("invalid tove display mode: " .. (mode or "nil"))
	end
	self:fetchChanges(lib.CHANGED_ANYTHING) -- clear all changes
end
end)()
Graphics._create = create
end)()
local Shape = (function()


local g = love.graphics

local Container = {}
Container.__index = Container

tove.newContainer = function()
	return setmetatable({x = 0, y = 0, r = 0, sx = 1, sy = 1,
		_children = {}}, Container)
end

function Container:draw()
	if next(self._children) ~= nil then
		g.push("transform")

		g.translate(self.x, self.y)
		g.rotate(self.r)
		g.scale(self.sx, self.sy)

		for _, child in ipairs(self._children) do
			child:draw()
		end

		g.pop()
	end
end

function Container:addChild(...)
	for _, child in ipairs({...}) do
		table.insert(self._children, child)
	end
end

function Container:addChildAt(...)
	local args = {...}
	local at = args[#p]
	args[#p] = nil
	for i, child in ipairs(args) do
		table.insert(self._children, at + i - 1, child)
	end
end

local function remove(t, x)
	for i, y in ipairs(t) do
		if x == y then
			table.remove(t, i)
			break
		end
	end
end

function Container:removeChild(...)
	for _, child in ipairs({...}) do
		remove(self._children, child)
	end
end

function Container:removeChildAt(...)
	for _, i in ipairs({...}) do
		table.remove(self._children, i)
	end
end

function Container:setChildIndex(child, index)
	self:removeChild(child, index)
	self:addChildAt(child, index)
end

tove.newStage = function()
	return tove.newContainer()
end


local Shape = {}
Shape.__index = Shape

tove.newShape = function(graphics)
	if graphics == nil then
		graphics = tove.newGraphics()
	end
	return setmetatable({graphics = graphics, x = 0, y = 0,
		r = 0, sx = 1, sy = 1, animation = nil}, Shape)
end

function Shape:animate(t)
	if self.animation ~= nil then
		if not self.animation:animate(self, t) then
			self.animation = nil
		end
	end

	for _, child in ipairs(self.children) do
		child:animate(t)
	end
end

function Shape:draw()
	self.graphics:draw(self.x, self.y, self.r, self.sx, self.sy)
end

function Shape:setDisplay(...)
	self.graphics:setDisplay(...)
end

function Shape:setFillColor(...)
	for _, path in self._graphics.paths do
		path:setFillColor(...)
	end
end

return Shape
end)()

local Animation = (function()

local function _linear(x)
	return x
end


local Tween = {}
Tween.__index = Tween

tove.newTween = function(graphics)
	return setmetatable({_graphics0 = graphics, _to = {}}, Tween)
end

function Tween:to(graphics, duration, ease)
	table.insert(self._to, {graphics = graphics, duration = duration, ease = ease or _linear})
	return self
end


local function createGraphics(graphics)
	if type(graphics) == "string" then
		graphics = tove.newGraphics(graphics)
	end
	return graphics
end

local Flipbook = {}

tove.newFlipbook = function(fps, tween, ...)
	display = {...}
	if next(display) == nil then
		display = {"bitmap"}
	end
	local frames = {}
	local looping = tween._graphics0 == tween._to[#tween._to].graphics
	for i, keyframe in ipairs(tween._to) do
		duration = math.ceil(keyframe.duration * fps)
		local g0 = frames[#frames]
		local j0 = 1
		if i == 1 then
			g0 = createGraphics(tween._graphics0)
			if not looping then
				j0 = 0
				duration = duration - 1
			end
		end
		local g1 = createGraphics(keyframe.graphics)
		local ease = keyframe.ease
		for j = j0, duration do
			if ease == "none" then
				table.insert(frames, j < duration and g0 or g1)
			else
				local inbetween = tove.newGraphics()
				inbetween:animate(g0, g1, ease(j / duration))
				inbetween:setDisplay(unpack(display))
				inbetween:cache()
				table.insert(frames, inbetween)
			end
		end
	end
	return setmetatable({_fps = fps, _frames = frames, _t = 0, _i = 1}, Flipbook)
end

Flipbook.__index = function(self, key)
	if key == "t" then
		return self._t
	else
		return Flipbook[key]
	end
end

Flipbook.__newindex = function(self, key, value)
	if key == "t" then
		self._t = value
		self._i = math.min(math.max(1,
			1 + math.floor(value * self._fps)), #self._frames)
	end
end

function Flipbook:draw(...)
	self._frames[self._i]:draw(...)
end


local Animation = {}

tove.newAnimation = function(tween, ...)
	display = {...}
	if next(display) == nil then
		display = {"mesh", 0.5} -- tove.fixed(2)
	end
	local keyframes = {}
	local graphics = tove.newGraphics()
	graphics:setUsage("points", "dynamic")
	graphics:setUsage("colors", "dynamic")
	graphics:setDisplay(unpack(display))
	local offset = 0

	do
		local g = createGraphics(tween._graphics0)
		graphics:animate(g, g, 0)
		graphics:cache()
		table.insert(keyframes, {graphics = g, offset = 0, duration = 0, ease = _linear})
	end

	for i, keyframe in ipairs(tween._to) do
		local g = createGraphics(keyframe.graphics)
		keyframe.graphics = g
		offset = offset + keyframe.duration
		keyframe.offset = offset
		graphics:animate(g, g, 0)
		graphics:cache() -- cache triangulation
		table.insert(keyframes, keyframe)
	end

	return setmetatable({_keyframes = keyframes, _graphics = graphics,
		_t = 0, _i = 1, _duration = 0}, Animation)
end

Animation.__newindex = function(self, key, value)
	if key == "t" then
		local t = math.min(math.max(value, 0), 1)
		self._t = t
		local f = self._keyframes
		local lo = 0
		local hi = #f
		while lo < hi do
			local mid = math.floor((lo + hi) / 2)
			if f[mid + 1].offset < t then
				lo = mid + 1
			else
				hi = mid
			end
		end
		lo = math.min(math.max(lo, 1), #f - 1)
		local f0 = f[lo]
		local f1 = f[lo + 1]
		self._graphics:animate(f0.graphics, f1.graphics,
			f1.ease((t - f0.offset) / f1.duration))
	end
end

Animation.__index = function(self, key)
	if key == "t" then
		return self._t
	else
		return Animation[key]
	end
end

function Animation:draw(...)
	self._graphics:draw(...)
end
end)()

	tove.warn = function(obj, text)
		print("TÖVE: " .. (text or obj))
	end

	tove.error = function(err)
		if err ~= 0 then
			if err == lib.ERR_TRIANGULATION_FAILED then
				tove.warn("triangulation failed.")
			else
				tove.warn("error #" .. tostring(err))
			end
		end
	end
end

tove.init()
